(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/common'),exports, require('rxjs'), require('rxjs/operators'), require('detect-passive-events'), require('@angular/core'), require('@angular/forms'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@angular-slider/ngx-slider', ['@angular/core','@angular/common','exports', 'rxjs', 'rxjs/operators', 'detect-passive-events', '@angular/core', '@angular/forms', '@angular/common'], factory) :
    (factory(global.ng.core,global.ng.common,(global['angular-slider'] = global['angular-slider'] || {}, global['angular-slider']['ngx-slider'] = {}),global.rxjs,global.rxjs.operators,null,global.ng.core,global.ng.forms,global.ng.common));
}(this, (function (ɵngcc0,ɵngcc1,exports,rxjs,operators,detectPassiveEvents,core,forms,common) { 
var _c0 = ["tooltipTemplate"];
var _c1 = ["leftOuterSelectionBar"];
var _c2 = ["rightOuterSelectionBar"];
var _c3 = ["fullBar"];
var _c4 = ["selectionBar"];
var _c5 = ["minHandle"];
var _c6 = ["maxHandle"];
var _c7 = ["floorLabel"];
var _c8 = ["ceilLabel"];
var _c9 = ["minHandleLabel"];
var _c10 = ["maxHandleLabel"];
var _c11 = ["combinedLabel"];
var _c12 = ["ticksElement"];
function SliderComponent_span_28_ngx_slider_tooltip_wrapper_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngx-slider-tooltip-wrapper", 31);
} if (rf & 2) {
    var t_r13 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r14 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("template", ctx_r14.tooltipTemplate)("tooltip", t_r13.valueTooltip)("placement", t_r13.valueTooltipPlacement)("content", t_r13.value);
} }
function SliderComponent_span_28_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 32);
} if (rf & 2) {
    var t_r13 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("innerHTML", t_r13.legend, ɵngcc0.ɵɵsanitizeHtml);
} }
var _c13 = function (a0) { return { "ngx-slider-selected": a0 }; };
function SliderComponent_span_28_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 27);
    ɵngcc0.ɵɵelement(1, "ngx-slider-tooltip-wrapper", 28);
    ɵngcc0.ɵɵtemplate(2, SliderComponent_span_28_ngx_slider_tooltip_wrapper_2_Template, 1, 4, "ngx-slider-tooltip-wrapper", 29);
    ɵngcc0.ɵɵtemplate(3, SliderComponent_span_28_span_3_Template, 1, 1, "span", 30);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var t_r13 = ctx.$implicit;
    var ctx_r12 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(7, _c13, t_r13.selected))("ngStyle", t_r13.style);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("template", ctx_r12.tooltipTemplate)("tooltip", t_r13.tooltip)("placement", t_r13.tooltipPlacement);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", t_r13.value != null);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", t_r13.legend != null);
} }
function TooltipWrapperComponent_ng_container_0_1_ng_template_0_Template(rf, ctx) { }
function TooltipWrapperComponent_ng_container_0_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TooltipWrapperComponent_ng_container_0_1_ng_template_0_Template, 0, 0, "ng-template");
} }
var _c14 = function (a0, a1, a2) { return { tooltip: a0, placement: a1, content: a2 }; };
function TooltipWrapperComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TooltipWrapperComponent_ng_container_0_1_Template, 1, 0, undefined, 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction3(2, _c14, ctx_r0.tooltip, ctx_r0.placement, ctx_r0.content));
} }
function TooltipWrapperComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("title", ctx_r1.tooltip)("data-tooltip-placement", ctx_r1.placement);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.content, " ");
} }
'use strict';

    detectPassiveEvents = detectPassiveEvents && detectPassiveEvents.hasOwnProperty('default') ? detectPassiveEvents['default'] : detectPassiveEvents;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p]; };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var LabelType = {
        /** Label above low pointer */
        Low: 0,
        /** Label above high pointer */
        High: 1,
        /** Label for minimum slider value */
        Floor: 2,
        /** Label for maximum slider value */
        Ceil: 3,
        /** Label below legend tick */
        TickValue: 4,
    };
    LabelType[LabelType.Low] = 'Low';
    LabelType[LabelType.High] = 'High';
    LabelType[LabelType.Floor] = 'Floor';
    LabelType[LabelType.Ceil] = 'Ceil';
    LabelType[LabelType.TickValue] = 'TickValue';
    /**
     * Slider options
     */
    var /**
     * Slider options
     */ Options = /** @class */ (function () {
        function Options() {
            /**
             * Minimum value for a slider.
             * Not applicable when using stepsArray.
             */
            this.floor = 0;
            /**
             * Maximum value for a slider.
             * Not applicable when using stepsArray.
             */
            this.ceil = null;
            /**
             * Step between each value.
             * Not applicable when using stepsArray.
             */
            this.step = 1;
            /**
             * The minimum range authorized on the slider.
             * Applies to range slider only.
             * When using stepsArray, expressed as index into stepsArray.
             */
            this.minRange = null;
            /**
             * The maximum range authorized on the slider.
             * Applies to range slider only.
             * When using stepsArray, expressed as index into stepsArray.
             */
            this.maxRange = null;
            /**
             * Set to true to have a push behavior. When the min handle goes above the max,
             * the max is moved as well (and vice-versa). The range between min and max is
             * defined by the step option (defaults to 1) and can also be overriden by
             * the minRange option. Applies to range slider only.
             */
            this.pushRange = false;
            /**
             * The minimum value authorized on the slider.
             * When using stepsArray, expressed as index into stepsArray.
             */
            this.minLimit = null;
            /**
             * The maximum value authorized on the slider.
             * When using stepsArray, expressed as index into stepsArray.
             */
            this.maxLimit = null;
            /**
             * Custom translate function. Use this if you want to translate values displayed
             * on the slider.
             */
            this.translate = null;
            /**
             * Custom function for combining overlapping labels in range slider.
             * It takes the min and max values (already translated with translate fuction)
             * and should return how these two values should be combined.
             * If not provided, the default function will join the two values with
             * ' - ' as separator.
             */
            this.combineLabels = null;
            /**
             * Use to display legend under ticks (thus, it needs to be used along with
             * showTicks or showTicksValues). The function will be called with each tick
             * value and returned content will be displayed under the tick as a legend.
             * If the returned value is null, then no legend is displayed under
             * the corresponding tick.You can also directly provide the legend values
             * in the stepsArray option.
             */
            this.getLegend = null;
            /**
             * If you want to display a slider with non linear/number steps.
             * Just pass an array with each slider value and that's it; the floor, ceil and step settings
             * of the slider will be computed automatically.
             * By default, the value model and valueHigh model values will be the value of the selected item
             * in the stepsArray.
             * They can also be bound to the index of the selected item by setting the bindIndexForStepsArray
             * option to true.
             */
            this.stepsArray = null;
            /**
             * Set to true to bind the index of the selected item to value model and valueHigh model.
             */
            this.bindIndexForStepsArray = false;
            /**
             * When set to true and using a range slider, the range can be dragged by the selection bar.
             * Applies to range slider only.
             */
            this.draggableRange = false;
            /**
             * Same as draggableRange but the slider range can't be changed.
             * Applies to range slider only.
             */
            this.draggableRangeOnly = false;
            /**
             * Set to true to always show the selection bar before the slider handle.
             */
            this.showSelectionBar = false;
            /**
             * Set to true to always show the selection bar after the slider handle.
             */
            this.showSelectionBarEnd = false;
            /**
             * Set a number to draw the selection bar between this value and the slider handle.
             * When using stepsArray, expressed as index into stepsArray.
             */
            this.showSelectionBarFromValue = null;
            /**
             * Only for range slider. Set to true to visualize in different colour the areas
             * on the left/right (top/bottom for vertical range slider) of selection bar between the handles.
             */
            this.showOuterSelectionBars = false;
            /**
             * Set to true to hide pointer labels
             */
            this.hidePointerLabels = false;
            /**
             * Set to true to hide min / max labels
             */
            this.hideLimitLabels = false;
            /**
             * Set to false to disable the auto-hiding behavior of the limit labels.
             */
            this.autoHideLimitLabels = true;
            /**
             * Set to true to make the slider read-only.
             */
            this.readOnly = false;
            /**
             * Set to true to disable the slider.
             */
            this.disabled = false;
            /**
             * Throttle interval for mouse events in milliseconds.
             * This is provided to avoid a flood of events when moving the slider with mouse.
             */
            this.mouseEventsInterval = 50;
            /**
             * Throttle interval for touch events in milliseconds.
             * This is provided to avoid a flood of events when moving the slider with touch gesture.
             */
            this.touchEventsInterval = 50;
            /**
             * Throttle interval for input changes (changes to bindings or reactive form inputs)
             * This is provided to avoid a flood of events on frequent input binding changes affecting performance.
             */
            this.inputEventsInterval = 100;
            /**
             * Throttle interval for output changes (signalling changes to output bindings and user callbacks)
             * This is provided to avoid a flood of outgoing events affecting Angular app performance.
             */
            this.outputEventsInterval = 100;
            /**
             * Set to true to display a tick for each step of the slider.
             */
            this.showTicks = false;
            /**
             * Set to true to display a tick and the step value for each step of the slider..
             */
            this.showTicksValues = false;
            /* The step between each tick to display. If not set, the step value is used.
                Not used when ticksArray is specified. */
            this.tickStep = null;
            /* The step between displaying each tick step value.
                If not set, then tickStep or step is used, depending on which one is set. */
            this.tickValueStep = null;
            /**
             * Use to display ticks at specific positions.
             * The array contains the index of the ticks that should be displayed.
             * For example, [0, 1, 5] will display a tick for the first, second and sixth values.
             */
            this.ticksArray = null;
            /**
             * Used to display a tooltip when a tick is hovered.
             * Set to a function that returns the tooltip content for a given value.
             */
            this.ticksTooltip = null;
            /**
             * Same as ticksTooltip but for ticks values.
             */
            this.ticksValuesTooltip = null;
            /**
             * Set to true to display the slider vertically.
             * The slider will take the full height of its parent.
             * Changing this value at runtime is not currently supported.
             */
            this.vertical = false;
            /**
             * Function that returns the current color of the selection bar.
             * If your color won't change, don't use this option but set it through CSS.
             * If the returned color depends on a model value (either value or valueHigh),
             * you should use the argument passed to the function.
             * Indeed, when the function is called, there is no certainty that the model
             * has already been updated.
             */
            this.getSelectionBarColor = null;
            /**
             * Function that returns the color of a tick. showTicks must be enabled.
             */
            this.getTickColor = null;
            /**
             * Function that returns the current color of a pointer.
             * If your color won't change, don't use this option but set it through CSS.
             * If the returned color depends on a model value (either value or valueHigh),
             * you should use the argument passed to the function.
             * Indeed, when the function is called, there is no certainty that the model has already been updated.
             * To handle range slider pointers independently, you should evaluate pointerType within the given
             * function where "min" stands for value model and "max" for valueHigh model values.
             */
            this.getPointerColor = null;
            /**
             * Handles are focusable (on click or with tab) and can be modified using the following keyboard controls:
             * Left/bottom arrows: -1
             * Right/top arrows: +1
             * Page-down: -10%
             * Page-up: +10%
             * Home: minimum value
             * End: maximum value
             */
            this.keyboardSupport = true;
            /**
             * If you display the slider in an element that uses transform: scale(0.5), set the scale value to 2
             * so that the slider is rendered properly and the events are handled correctly.
             */
            this.scale = 1;
            /**
             * Set to true to force the value(s) to be rounded to the step, even when modified from the outside.
             * When set to false, if the model values are modified from outside the slider, they are not rounded
             * and can be between two steps.
             */
            this.enforceStep = true;
            /**
             * Set to true to force the value(s) to be normalised to allowed range (floor to ceil), even when modified from the outside.
             * When set to false, if the model values are modified from outside the slider, and they are outside allowed range,
             * the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation.
             */
            this.enforceRange = true;
            /**
             * Set to true to force the value(s) to be rounded to the nearest step value, even when modified from the outside.
             * When set to false, if the model values are modified from outside the slider, and they are outside allowed range,
             * the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation.
             */
            this.enforceStepsArray = true;
            /**
             * Set to true to prevent to user from switching the min and max handles. Applies to range slider only.
             */
            this.noSwitching = false;
            /**
             * Set to true to only bind events on slider handles.
             */
            this.onlyBindHandles = false;
            /**
             * Set to true to show graphs right to left.
             * If vertical is true it will be from top to bottom and left / right arrow functions reversed.
             */
            this.rightToLeft = false;
            /**
             * Set to true to reverse keyboard navigation:
             * Right/top arrows: -1
             * Left/bottom arrows: +1
             * Page-up: -10%
             * Page-down: +10%
             * End: minimum value
             * Home: maximum value
             */
            this.reversedControls = false;
            /**
             * Set to true to keep the slider labels inside the slider bounds.
             */
            this.boundPointerLabels = true;
            /**
             * Set to true to use a logarithmic scale to display the slider.
             */
            this.logScale = false;
            /**
             * Function that returns the position on the slider for a given value.
             * The position must be a percentage between 0 and 1.
             * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.
             */
            this.customValueToPosition = null;
            /**
             * Function that returns the value for a given position on the slider.
             * The position is a percentage between 0 and 1.
             * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.
             */
            this.customPositionToValue = null;
            /**
             * Precision limit for calculated values.
             * Values used in calculations will be rounded to this number of significant digits
             * to prevent accumulating small floating-point errors.
             */
            this.precisionLimit = 12;
            /**
             * Use to display the selection bar as a gradient.
             * The given object must contain from and to properties which are colors.
             */
            this.selectionBarGradient = null;
            /**
             * Use to add a label directly to the slider for accessibility. Adds the aria-label attribute.
             */
            this.ariaLabel = null;
            /**
             * Use instead of ariaLabel to reference the id of an element which will be used to label the slider.
             * Adds the aria-labelledby attribute.
             */
            this.ariaLabelledBy = null;
            /**
             * Use to add a label directly to the slider range for accessibility. Adds the aria-label attribute.
             */
            this.ariaLabelHigh = null;
            /**
             * Use instead of ariaLabelHigh to reference the id of an element which will be used to label the slider range.
             * Adds the aria-labelledby attribute.
             */
            this.ariaLabelledByHigh = null;
            /**
             * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the handle
             */
            this.handleDimension = null;
            /**
             * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the bar
             */
            this.barDimension = null;
            /**
             * Enable/disable CSS animations
             */
            this.animate = true;
            /**
             * Enable/disable CSS animations while moving the slider
             */
            this.animateOnMove = false;
        }
        return Options;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var PointerType = {
        /** Low pointer */
        Min: 0,
        /** High pointer */
        Max: 1,
    };
    PointerType[PointerType.Min] = 'Min';
    PointerType[PointerType.Max] = 'Max';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ChangeContext = /** @class */ (function () {
        function ChangeContext() {
        }
        return ChangeContext;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *  Collection of functions to handle conversions/lookups of values
     */
    var /**
     *  Collection of functions to handle conversions/lookups of values
     */ ValueHelper = /** @class */ (function () {
        function ValueHelper() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ValueHelper.isNullOrUndefined = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return value === undefined || value === null;
            };
        /**
         * @param {?} array1
         * @param {?} array2
         * @return {?}
         */
        ValueHelper.areArraysEqual = /**
         * @param {?} array1
         * @param {?} array2
         * @return {?}
         */
            function (array1, array2) {
                if (array1.length !== array2.length) {
                    return false;
                }
                for (var i = 0; i < array1.length; ++i) {
                    if (array1[i] !== array2[i]) {
                        return false;
                    }
                }
                return true;
            };
        /**
         * @param {?} val
         * @param {?} minVal
         * @param {?} maxVal
         * @return {?}
         */
        ValueHelper.linearValueToPosition = /**
         * @param {?} val
         * @param {?} minVal
         * @param {?} maxVal
         * @return {?}
         */
            function (val, minVal, maxVal) {
                /** @type {?} */
                var range = maxVal - minVal;
                return (val - minVal) / range;
            };
        /**
         * @param {?} val
         * @param {?} minVal
         * @param {?} maxVal
         * @return {?}
         */
        ValueHelper.logValueToPosition = /**
         * @param {?} val
         * @param {?} minVal
         * @param {?} maxVal
         * @return {?}
         */
            function (val, minVal, maxVal) {
                val = Math.log(val);
                minVal = Math.log(minVal);
                maxVal = Math.log(maxVal);
                /** @type {?} */
                var range = maxVal - minVal;
                return (val - minVal) / range;
            };
        /**
         * @param {?} percent
         * @param {?} minVal
         * @param {?} maxVal
         * @return {?}
         */
        ValueHelper.linearPositionToValue = /**
         * @param {?} percent
         * @param {?} minVal
         * @param {?} maxVal
         * @return {?}
         */
            function (percent, minVal, maxVal) {
                return percent * (maxVal - minVal) + minVal;
            };
        /**
         * @param {?} percent
         * @param {?} minVal
         * @param {?} maxVal
         * @return {?}
         */
        ValueHelper.logPositionToValue = /**
         * @param {?} percent
         * @param {?} minVal
         * @param {?} maxVal
         * @return {?}
         */
            function (percent, minVal, maxVal) {
                minVal = Math.log(minVal);
                maxVal = Math.log(maxVal);
                /** @type {?} */
                var value = percent * (maxVal - minVal) + minVal;
                return Math.exp(value);
            };
        /**
         * @param {?} modelValue
         * @param {?} stepsArray
         * @return {?}
         */
        ValueHelper.findStepIndex = /**
         * @param {?} modelValue
         * @param {?} stepsArray
         * @return {?}
         */
            function (modelValue, stepsArray) {
                /** @type {?} */
                var differences = stepsArray.map(function (step) { return Math.abs(modelValue - step.value); });
                /** @type {?} */
                var minDifferenceIndex = 0;
                for (var index = 0; index < stepsArray.length; index++) {
                    if (differences[index] !== differences[minDifferenceIndex] && differences[index] < differences[minDifferenceIndex]) {
                        minDifferenceIndex = index;
                    }
                }
                return minDifferenceIndex;
            };
        return ValueHelper;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Helper with compatibility functions to support different browsers
     */
    var /**
     * Helper with compatibility functions to support different browsers
     */ CompatibilityHelper = /** @class */ (function () {
        function CompatibilityHelper() {
        }
        /**
         * Workaround for TouchEvent constructor sadly not being available on all browsers (e.g. Firefox, Safari)
         * @param {?} event
         * @return {?}
         */
        CompatibilityHelper.isTouchEvent = /**
         * Workaround for TouchEvent constructor sadly not being available on all browsers (e.g. Firefox, Safari)
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (( /** @type {?} */(window)).TouchEvent !== undefined) {
                    return event instanceof TouchEvent;
                }
                return event.touches !== undefined;
            };
        /**
         * Detect presence of ResizeObserver API
         * @return {?}
         */
        CompatibilityHelper.isResizeObserverAvailable = /**
         * Detect presence of ResizeObserver API
         * @return {?}
         */
            function () {
                return ( /** @type {?} */(window)).ResizeObserver !== undefined;
            };
        return CompatibilityHelper;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Helper with mathematical functions
     */
    var /**
     * Helper with mathematical functions
     */ MathHelper = /** @class */ (function () {
        function MathHelper() {
        }
        /* Round numbers to a given number of significant digits */
        /**
         * @param {?} value
         * @param {?} precisionLimit
         * @return {?}
         */
        MathHelper.roundToPrecisionLimit = /**
         * @param {?} value
         * @param {?} precisionLimit
         * @return {?}
         */
            function (value, precisionLimit) {
                return +(value.toPrecision(precisionLimit));
            };
        /**
         * @param {?} value
         * @param {?} modulo
         * @param {?} precisionLimit
         * @return {?}
         */
        MathHelper.isModuloWithinPrecisionLimit = /**
         * @param {?} value
         * @param {?} modulo
         * @param {?} precisionLimit
         * @return {?}
         */
            function (value, modulo, precisionLimit) {
                /** @type {?} */
                var limit = Math.pow(10, -precisionLimit);
                return Math.abs(value % modulo) <= limit || Math.abs(Math.abs(value % modulo) - modulo) <= limit;
            };
        /**
         * @param {?} value
         * @param {?} floor
         * @param {?} ceil
         * @return {?}
         */
        MathHelper.clampToRange = /**
         * @param {?} value
         * @param {?} floor
         * @param {?} ceil
         * @return {?}
         */
            function (value, floor, ceil) {
                return Math.min(Math.max(value, floor), ceil);
            };
        return MathHelper;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var EventListener = /** @class */ (function () {
        function EventListener() {
            this.eventName = null;
            this.events = null;
            this.eventsSubscription = null;
            this.teardownCallback = null;
        }
        return EventListener;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Helper class to attach event listeners to DOM elements with debounce support using rxjs
     */
    var /**
     * Helper class to attach event listeners to DOM elements with debounce support using rxjs
     */ EventListenerHelper = /** @class */ (function () {
        function EventListenerHelper(renderer) {
            this.renderer = renderer;
        }
        /**
         * @param {?} nativeElement
         * @param {?} eventName
         * @param {?} callback
         * @param {?=} throttleInterval
         * @return {?}
         */
        EventListenerHelper.prototype.attachPassiveEventListener = /**
         * @param {?} nativeElement
         * @param {?} eventName
         * @param {?} callback
         * @param {?=} throttleInterval
         * @return {?}
         */
            function (nativeElement, eventName, callback, throttleInterval) {
                // Only use passive event listeners if the browser supports it
                if (detectPassiveEvents.hasSupport !== true) {
                    return this.attachEventListener(nativeElement, eventName, callback, throttleInterval);
                }
                /** @type {?} */
                var listener = new EventListener();
                listener.eventName = eventName;
                listener.events = new rxjs.Subject();
                /** @type {?} */
                var observerCallback = function (event) {
                    listener.events.next(event);
                };
                nativeElement.addEventListener(eventName, observerCallback, { passive: true, capture: false });
                listener.teardownCallback = function () {
                    nativeElement.removeEventListener(eventName, observerCallback, { passive: true, capture: false });
                };
                listener.eventsSubscription = listener.events
                    .pipe((!ValueHelper.isNullOrUndefined(throttleInterval))
                    ? operators.throttleTime(throttleInterval, undefined, { leading: true, trailing: true })
                    : operators.tap(function () { }) // no-op
                )
                    .subscribe(function (event) {
                    callback(event);
                });
                return listener;
            };
        /**
         * @param {?} eventListener
         * @return {?}
         */
        EventListenerHelper.prototype.detachEventListener = /**
         * @param {?} eventListener
         * @return {?}
         */
            function (eventListener) {
                if (!ValueHelper.isNullOrUndefined(eventListener.eventsSubscription)) {
                    eventListener.eventsSubscription.unsubscribe();
                    eventListener.eventsSubscription = null;
                }
                if (!ValueHelper.isNullOrUndefined(eventListener.events)) {
                    eventListener.events.complete();
                    eventListener.events = null;
                }
                if (!ValueHelper.isNullOrUndefined(eventListener.teardownCallback)) {
                    eventListener.teardownCallback();
                    eventListener.teardownCallback = null;
                }
            };
        /**
         * @param {?} nativeElement
         * @param {?} eventName
         * @param {?} callback
         * @param {?=} throttleInterval
         * @return {?}
         */
        EventListenerHelper.prototype.attachEventListener = /**
         * @param {?} nativeElement
         * @param {?} eventName
         * @param {?} callback
         * @param {?=} throttleInterval
         * @return {?}
         */
            function (nativeElement, eventName, callback, throttleInterval) {
                /** @type {?} */
                var listener = new EventListener();
                listener.eventName = eventName;
                listener.events = new rxjs.Subject();
                /** @type {?} */
                var observerCallback = function (event) {
                    listener.events.next(event);
                };
                listener.teardownCallback = this.renderer.listen(nativeElement, eventName, observerCallback);
                listener.eventsSubscription = listener.events
                    .pipe((!ValueHelper.isNullOrUndefined(throttleInterval))
                    ? operators.throttleTime(throttleInterval, undefined, { leading: true, trailing: true })
                    : operators.tap(function () { }) // no-op
                )
                    .subscribe(function (event) { callback(event); });
                return listener;
            };
        return EventListenerHelper;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var SliderElementDirective = /** @class */ (function () {
        function SliderElementDirective(elemRef, renderer, changeDetectionRef) {
            this.elemRef = elemRef;
            this.renderer = renderer;
            this.changeDetectionRef = changeDetectionRef;
            this._position = 0;
            this._dimension = 0;
            this._alwaysHide = false;
            this._vertical = false;
            this._scale = 1;
            this.opacity = 1;
            this.visibility = 'visible';
            this.left = '';
            this.bottom = '';
            this.height = '';
            this.width = '';
            this.eventListeners = [];
            this.eventListenerHelper = new EventListenerHelper(this.renderer);
        }
        Object.defineProperty(SliderElementDirective.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                return this._position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderElementDirective.prototype, "dimension", {
            get: /**
             * @return {?}
             */ function () {
                return this._dimension;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderElementDirective.prototype, "alwaysHide", {
            get: /**
             * @return {?}
             */ function () {
                return this._alwaysHide;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderElementDirective.prototype, "vertical", {
            get: /**
             * @return {?}
             */ function () {
                return this._vertical;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderElementDirective.prototype, "scale", {
            get: /**
             * @return {?}
             */ function () {
                return this._scale;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} hide
         * @return {?}
         */
        SliderElementDirective.prototype.setAlwaysHide = /**
         * @param {?} hide
         * @return {?}
         */
            function (hide) {
                this._alwaysHide = hide;
                if (hide) {
                    this.visibility = 'hidden';
                }
                else {
                    this.visibility = 'visible';
                }
            };
        /**
         * @return {?}
         */
        SliderElementDirective.prototype.hide = /**
         * @return {?}
         */
            function () {
                this.opacity = 0;
            };
        /**
         * @return {?}
         */
        SliderElementDirective.prototype.show = /**
         * @return {?}
         */
            function () {
                if (this.alwaysHide) {
                    return;
                }
                this.opacity = 1;
            };
        /**
         * @return {?}
         */
        SliderElementDirective.prototype.isVisible = /**
         * @return {?}
         */
            function () {
                if (this.alwaysHide) {
                    return false;
                }
                return this.opacity !== 0;
            };
        /**
         * @param {?} vertical
         * @return {?}
         */
        SliderElementDirective.prototype.setVertical = /**
         * @param {?} vertical
         * @return {?}
         */
            function (vertical) {
                this._vertical = vertical;
                if (this._vertical) {
                    this.left = '';
                    this.width = '';
                }
                else {
                    this.bottom = '';
                    this.height = '';
                }
            };
        /**
         * @param {?} scale
         * @return {?}
         */
        SliderElementDirective.prototype.setScale = /**
         * @param {?} scale
         * @return {?}
         */
            function (scale) {
                this._scale = scale;
            };
        // Set element left/top position depending on whether slider is horizontal or vertical
        /**
         * @param {?} pos
         * @return {?}
         */
        SliderElementDirective.prototype.setPosition = /**
         * @param {?} pos
         * @return {?}
         */
            function (pos) {
                if (this._position !== pos && !this.isRefDestroyed()) {
                    this.changeDetectionRef.markForCheck();
                }
                this._position = pos;
                if (this._vertical) {
                    this.bottom = Math.round(pos) + 'px';
                }
                else {
                    this.left = Math.round(pos) + 'px';
                }
            };
        // Calculate element's width/height depending on whether slider is horizontal or vertical
        /**
         * @return {?}
         */
        SliderElementDirective.prototype.calculateDimension = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var val = this.getBoundingClientRect();
                if (this.vertical) {
                    this._dimension = (val.bottom - val.top) * this.scale;
                }
                else {
                    this._dimension = (val.right - val.left) * this.scale;
                }
            };
        // Set element width/height depending on whether slider is horizontal or vertical
        /**
         * @param {?} dim
         * @return {?}
         */
        SliderElementDirective.prototype.setDimension = /**
         * @param {?} dim
         * @return {?}
         */
            function (dim) {
                if (this._dimension !== dim && !this.isRefDestroyed()) {
                    this.changeDetectionRef.markForCheck();
                }
                this._dimension = dim;
                if (this._vertical) {
                    this.height = Math.round(dim) + 'px';
                }
                else {
                    this.width = Math.round(dim) + 'px';
                }
            };
        /**
         * @return {?}
         */
        SliderElementDirective.prototype.getBoundingClientRect = /**
         * @return {?}
         */
            function () {
                return this.elemRef.nativeElement.getBoundingClientRect();
            };
        /**
         * @param {?} eventName
         * @param {?} callback
         * @param {?=} debounceInterval
         * @return {?}
         */
        SliderElementDirective.prototype.on = /**
         * @param {?} eventName
         * @param {?} callback
         * @param {?=} debounceInterval
         * @return {?}
         */
            function (eventName, callback, debounceInterval) {
                /** @type {?} */
                var listener = this.eventListenerHelper.attachEventListener(this.elemRef.nativeElement, eventName, callback, debounceInterval);
                this.eventListeners.push(listener);
            };
        /**
         * @param {?} eventName
         * @param {?} callback
         * @param {?=} debounceInterval
         * @return {?}
         */
        SliderElementDirective.prototype.onPassive = /**
         * @param {?} eventName
         * @param {?} callback
         * @param {?=} debounceInterval
         * @return {?}
         */
            function (eventName, callback, debounceInterval) {
                /** @type {?} */
                var listener = this.eventListenerHelper.attachPassiveEventListener(this.elemRef.nativeElement, eventName, callback, debounceInterval);
                this.eventListeners.push(listener);
            };
        /**
         * @param {?=} eventName
         * @return {?}
         */
        SliderElementDirective.prototype.off = /**
         * @param {?=} eventName
         * @return {?}
         */
            function (eventName) {
                /** @type {?} */
                var listenersToKeep;
                /** @type {?} */
                var listenersToRemove;
                if (!ValueHelper.isNullOrUndefined(eventName)) {
                    listenersToKeep = this.eventListeners.filter(function (event) { return event.eventName !== eventName; });
                    listenersToRemove = this.eventListeners.filter(function (event) { return event.eventName === eventName; });
                }
                else {
                    listenersToKeep = [];
                    listenersToRemove = this.eventListeners;
                }
                try {
                    for (var listenersToRemove_1 = __values(listenersToRemove), listenersToRemove_1_1 = listenersToRemove_1.next(); !listenersToRemove_1_1.done; listenersToRemove_1_1 = listenersToRemove_1.next()) {
                        var listener = listenersToRemove_1_1.value;
                        this.eventListenerHelper.detachEventListener(listener);
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (listenersToRemove_1_1 && !listenersToRemove_1_1.done && (_a = listenersToRemove_1.return))
                            _a.call(listenersToRemove_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                this.eventListeners = listenersToKeep;
                var e_1, _a;
            };
        /**
         * @return {?}
         */
        SliderElementDirective.prototype.isRefDestroyed = /**
         * @return {?}
         */
            function () {
                return ValueHelper.isNullOrUndefined(this.changeDetectionRef) || this.changeDetectionRef['destroyed'];
            };
        /** @nocollapse */
        SliderElementDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: core.ChangeDetectorRef }
            ];
        };
        SliderElementDirective.propDecorators = {
            opacity: [{ type: core.HostBinding, args: ['style.opacity',] }],
            visibility: [{ type: core.HostBinding, args: ['style.visibility',] }],
            left: [{ type: core.HostBinding, args: ['style.left',] }],
            bottom: [{ type: core.HostBinding, args: ['style.bottom',] }],
            height: [{ type: core.HostBinding, args: ['style.height',] }],
            width: [{ type: core.HostBinding, args: ['style.width',] }]
        };
SliderElementDirective.ɵfac = function SliderElementDirective_Factory(t) { return new (t || SliderElementDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
SliderElementDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SliderElementDirective, selectors: [["", "ngxSliderElement", ""]], hostVars: 12, hostBindings: function SliderElementDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("opacity", ctx.opacity)("visibility", ctx.visibility)("left", ctx.left)("bottom", ctx.bottom)("height", ctx.height)("width", ctx.width);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SliderElementDirective, [{
        type: core.Directive,
        args: [{
                selector: '[ngxSliderElement]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { opacity: [{
            type: core.HostBinding,
            args: ['style.opacity']
        }], visibility: [{
            type: core.HostBinding,
            args: ['style.visibility']
        }], left: [{
            type: core.HostBinding,
            args: ['style.left']
        }], bottom: [{
            type: core.HostBinding,
            args: ['style.bottom']
        }], height: [{
            type: core.HostBinding,
            args: ['style.height']
        }], width: [{
            type: core.HostBinding,
            args: ['style.width']
        }] }); })();
        return SliderElementDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var SliderHandleDirective = /** @class */ (function (_super) {
        __extends(SliderHandleDirective, _super);
        function SliderHandleDirective(elemRef, renderer, changeDetectionRef) {
            var _this = _super.call(this, elemRef, renderer, changeDetectionRef) || this;
            _this.active = false;
            _this.role = '';
            _this.tabindex = '';
            _this.ariaOrientation = '';
            _this.ariaLabel = '';
            _this.ariaLabelledBy = '';
            _this.ariaValueNow = '';
            _this.ariaValueText = '';
            _this.ariaValueMin = '';
            _this.ariaValueMax = '';
            return _this;
        }
        /**
         * @return {?}
         */
        SliderHandleDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                this.elemRef.nativeElement.focus();
            };
        /** @nocollapse */
        SliderHandleDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: core.ChangeDetectorRef }
            ];
        };
        SliderHandleDirective.propDecorators = {
            active: [{ type: core.HostBinding, args: ['class.ngx-slider-active',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            tabindex: [{ type: core.HostBinding, args: ['attr.tabindex',] }],
            ariaOrientation: [{ type: core.HostBinding, args: ['attr.aria-orientation',] }],
            ariaLabel: [{ type: core.HostBinding, args: ['attr.aria-label',] }],
            ariaLabelledBy: [{ type: core.HostBinding, args: ['attr.aria-labelledby',] }],
            ariaValueNow: [{ type: core.HostBinding, args: ['attr.aria-valuenow',] }],
            ariaValueText: [{ type: core.HostBinding, args: ['attr.aria-valuetext',] }],
            ariaValueMin: [{ type: core.HostBinding, args: ['attr.aria-valuemin',] }],
            ariaValueMax: [{ type: core.HostBinding, args: ['attr.aria-valuemax',] }]
        };
SliderHandleDirective.ɵfac = function SliderHandleDirective_Factory(t) { return new (t || SliderHandleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
SliderHandleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SliderHandleDirective, selectors: [["", "ngxSliderHandle", ""]], hostVars: 11, hostBindings: function SliderHandleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("tabindex", ctx.tabindex)("aria-orientation", ctx.ariaOrientation)("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledBy)("aria-valuenow", ctx.ariaValueNow)("aria-valuetext", ctx.ariaValueText)("aria-valuemin", ctx.ariaValueMin)("aria-valuemax", ctx.ariaValueMax);
        ɵngcc0.ɵɵclassProp("ngx-slider-active", ctx.active);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SliderHandleDirective, [{
        type: core.Directive,
        args: [{
                selector: '[ngxSliderHandle]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { active: [{
            type: core.HostBinding,
            args: ['class.ngx-slider-active']
        }], role: [{
            type: core.HostBinding,
            args: ['attr.role']
        }], tabindex: [{
            type: core.HostBinding,
            args: ['attr.tabindex']
        }], ariaOrientation: [{
            type: core.HostBinding,
            args: ['attr.aria-orientation']
        }], ariaLabel: [{
            type: core.HostBinding,
            args: ['attr.aria-label']
        }], ariaLabelledBy: [{
            type: core.HostBinding,
            args: ['attr.aria-labelledby']
        }], ariaValueNow: [{
            type: core.HostBinding,
            args: ['attr.aria-valuenow']
        }], ariaValueText: [{
            type: core.HostBinding,
            args: ['attr.aria-valuetext']
        }], ariaValueMin: [{
            type: core.HostBinding,
            args: ['attr.aria-valuemin']
        }], ariaValueMax: [{
            type: core.HostBinding,
            args: ['attr.aria-valuemax']
        }] }); })();
        return SliderHandleDirective;
    }(SliderElementDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var SliderLabelDirective = /** @class */ (function (_super) {
        __extends(SliderLabelDirective, _super);
        function SliderLabelDirective(elemRef, renderer, changeDetectionRef) {
            var _this = _super.call(this, elemRef, renderer, changeDetectionRef) || this;
            _this._value = null;
            return _this;
        }
        Object.defineProperty(SliderLabelDirective.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        SliderLabelDirective.prototype.setValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var recalculateDimension = false;
                if (!this.alwaysHide &&
                    (ValueHelper.isNullOrUndefined(this.value) ||
                        this.value.length !== value.length ||
                        (this.value.length > 0 && this.dimension === 0))) {
                    recalculateDimension = true;
                }
                this._value = value;
                this.elemRef.nativeElement.innerHTML = value;
                // Update dimension only when length of the label have changed
                if (recalculateDimension) {
                    this.calculateDimension();
                }
            };
        /** @nocollapse */
        SliderLabelDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: core.ChangeDetectorRef }
            ];
        };
SliderLabelDirective.ɵfac = function SliderLabelDirective_Factory(t) { return new (t || SliderLabelDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
SliderLabelDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SliderLabelDirective, selectors: [["", "ngxSliderLabel", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SliderLabelDirective, [{
        type: core.Directive,
        args: [{
                selector: '[ngxSliderLabel]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
        return SliderLabelDirective;
    }(SliderElementDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var Tick = /** @class */ (function () {
        function Tick() {
            this.selected = false;
            this.style = {};
            this.tooltip = null;
            this.tooltipPlacement = null;
            this.value = null;
            this.valueTooltip = null;
            this.valueTooltipPlacement = null;
            this.legend = null;
        }
        return Tick;
    }());
    var Dragging = /** @class */ (function () {
        function Dragging() {
            this.active = false;
            this.value = 0;
            this.difference = 0;
            this.position = 0;
            this.lowLimit = 0;
            this.highLimit = 0;
        }
        return Dragging;
    }());
    var ModelValues = /** @class */ (function () {
        function ModelValues() {
        }
        /**
         * @param {?=} x
         * @param {?=} y
         * @return {?}
         */
        ModelValues.compare = /**
         * @param {?=} x
         * @param {?=} y
         * @return {?}
         */
            function (x, y) {
                if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {
                    return false;
                }
                if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {
                    return false;
                }
                return x.value === y.value && x.highValue === y.highValue;
            };
        return ModelValues;
    }());
    var ModelChange = /** @class */ (function (_super) {
        __extends(ModelChange, _super);
        function ModelChange() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?=} x
         * @param {?=} y
         * @return {?}
         */
        ModelChange.compare = /**
         * @param {?=} x
         * @param {?=} y
         * @return {?}
         */
            function (x, y) {
                if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {
                    return false;
                }
                if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {
                    return false;
                }
                return x.value === y.value &&
                    x.highValue === y.highValue &&
                    x.forceChange === y.forceChange;
            };
        return ModelChange;
    }(ModelValues));
    var InputModelChange = /** @class */ (function (_super) {
        __extends(InputModelChange, _super);
        function InputModelChange() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return InputModelChange;
    }(ModelChange));
    var OutputModelChange = /** @class */ (function (_super) {
        __extends(OutputModelChange, _super);
        function OutputModelChange() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return OutputModelChange;
    }(ModelChange));
    /** @type {?} */
    var NGX_SLIDER_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        /* tslint:disable-next-line: no-use-before-declare */
        useExisting: core.forwardRef(function () { return SliderComponent; }),
        multi: true,
    };
    var SliderComponent = /** @class */ (function () {
        function SliderComponent(renderer, elementRef, changeDetectionRef, zone) {
            this.renderer = renderer;
            this.elementRef = elementRef;
            this.changeDetectionRef = changeDetectionRef;
            this.zone = zone;
            // Model for low value of slider. For simple slider, this is the only input. For range slider, this is the low value.
            this.value = null;
            // Output for low value slider to support two-way bindings
            this.valueChange = new core.EventEmitter();
            // Model for high value of slider. Not used in simple slider. For range slider, this is the high value.
            this.highValue = null;
            // Output for high value slider to support two-way bindings
            this.highValueChange = new core.EventEmitter();
            // An object with all the other options of the slider.
            // Each option can be updated at runtime and the slider will automatically be re-rendered.
            this.options = new Options();
            // Event emitted when user starts interaction with the slider
            this.userChangeStart = new core.EventEmitter();
            // Event emitted on each change coming from user interaction
            this.userChange = new core.EventEmitter();
            // Event emitted when user finishes interaction with the slider
            this.userChangeEnd = new core.EventEmitter();
            this.initHasRun = false;
            this.inputModelChangeSubject = new rxjs.Subject();
            this.inputModelChangeSubscription = null;
            this.outputModelChangeSubject = new rxjs.Subject();
            this.outputModelChangeSubscription = null;
            this.viewLowValue = null;
            this.viewHighValue = null;
            this.viewOptions = new Options();
            this.handleHalfDimension = 0;
            this.maxHandlePosition = 0;
            this.currentTrackingPointer = null;
            this.currentFocusPointer = null;
            this.firstKeyDown = false;
            this.touchId = null;
            this.dragging = new Dragging();
            // Host element class bindings
            this.sliderElementVerticalClass = false;
            this.sliderElementAnimateClass = false;
            this.sliderElementWithLegendClass = false;
            this.sliderElementDisabledAttr = null;
            this.barStyle = {};
            this.minPointerStyle = {};
            this.maxPointerStyle = {};
            this.fullBarTransparentClass = false;
            this.selectionBarDraggableClass = false;
            this.ticksUnderValuesClass = false;
            this.intermediateTicks = false;
            this.ticks = [];
            this.eventListenerHelper = null;
            this.onMoveEventListener = null;
            this.onEndEventListener = null;
            this.moving = false;
            this.resizeObserver = null;
            this.onTouchedCallback = null;
            this.onChangeCallback = null;
            this.eventListenerHelper = new EventListenerHelper(this.renderer);
        }
        Object.defineProperty(SliderComponent.prototype, "manualRefresh", {
            // Input event that triggers slider refresh (re-positioning of slider elements)
            set: /**
             * @param {?} manualRefresh
             * @return {?}
             */ function (manualRefresh) {
                var _this = this;
                this.unsubscribeManualRefresh();
                this.manualRefreshSubscription = manualRefresh.subscribe(function () {
                    setTimeout(function () { return _this.calculateViewDimensionsAndDetectChanges(); });
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderComponent.prototype, "triggerFocus", {
            // Input event that triggers setting focus on given slider handle
            set: /**
             * @param {?} triggerFocus
             * @return {?}
             */ function (triggerFocus) {
                var _this = this;
                this.unsubscribeTriggerFocus();
                this.triggerFocusSubscription = triggerFocus.subscribe(function (pointerType) {
                    _this.focusPointer(pointerType);
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderComponent.prototype, "range", {
            get: /**
             * @return {?}
             */ function () {
                return !ValueHelper.isNullOrUndefined(this.value) && !ValueHelper.isNullOrUndefined(this.highValue);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliderComponent.prototype, "showTicks", {
            get: /**
             * @return {?}
             */ function () {
                return this.viewOptions.showTicks;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.viewOptions = new Options();
                Object.assign(this.viewOptions, this.options);
                // We need to run these two things first, before the rest of the init in ngAfterViewInit(),
                // because these two settings are set through @HostBinding and Angular change detection
                // mechanism doesn't like them changing in ngAfterViewInit()
                this.updateDisabledState();
                this.updateVerticalState();
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.applyOptions();
                this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval);
                this.subscribeOutputModelChangeSubject(this.viewOptions.outputEventsInterval);
                // Once we apply options, we need to normalise model values for the first time
                this.renormaliseModelValues();
                this.viewLowValue = this.modelValueToViewValue(this.value);
                if (this.range) {
                    this.viewHighValue = this.modelValueToViewValue(this.highValue);
                }
                else {
                    this.viewHighValue = null;
                }
                this.updateVerticalState(); // need to run this again to cover changes to slider elements
                this.manageElementsStyle();
                this.updateDisabledState();
                this.calculateViewDimensions();
                this.addAccessibility();
                this.updateCeilLabel();
                this.updateFloorLabel();
                this.initHandles();
                this.manageEventsBindings();
                this.subscribeResizeObserver();
                this.initHasRun = true;
                // Run change detection manually to resolve some issues when init procedure changes values used in the view
                if (!this.isRefDestroyed()) {
                    this.changeDetectionRef.detectChanges();
                }
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        SliderComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                // Always apply options first
                if (!ValueHelper.isNullOrUndefined(changes["options"])) {
                    this.onChangeOptions();
                }
                // Then value changes
                if (!ValueHelper.isNullOrUndefined(changes["value"]) ||
                    !ValueHelper.isNullOrUndefined(changes["highValue"])) {
                    this.inputModelChangeSubject.next({
                        value: this.value,
                        highValue: this.highValue,
                        forceChange: false,
                        internalChange: false
                    });
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.unbindEvents();
                this.unsubscribeResizeObserver();
                this.unsubscribeInputModelChangeSubject();
                this.unsubscribeOutputModelChangeSubject();
                this.unsubscribeManualRefresh();
                this.unsubscribeTriggerFocus();
            };
        /**
         * @param {?} obj
         * @return {?}
         */
        SliderComponent.prototype.writeValue = /**
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
                if (obj instanceof Array) {
                    this.value = obj[0];
                    this.highValue = obj[1];
                }
                else {
                    this.value = obj;
                }
                // ngOnChanges() is not called in this instance, so we need to communicate the change manually
                this.inputModelChangeSubject.next({
                    value: this.value,
                    highValue: this.highValue,
                    forceChange: false,
                    internalChange: false
                });
            };
        /**
         * @param {?} onChangeCallback
         * @return {?}
         */
        SliderComponent.prototype.registerOnChange = /**
         * @param {?} onChangeCallback
         * @return {?}
         */
            function (onChangeCallback) {
                this.onChangeCallback = onChangeCallback;
            };
        /**
         * @param {?} onTouchedCallback
         * @return {?}
         */
        SliderComponent.prototype.registerOnTouched = /**
         * @param {?} onTouchedCallback
         * @return {?}
         */
            function (onTouchedCallback) {
                this.onTouchedCallback = onTouchedCallback;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        SliderComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.viewOptions.disabled = isDisabled;
                this.updateDisabledState();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SliderComponent.prototype.onResize = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.calculateViewDimensionsAndDetectChanges();
            };
        /**
         * @param {?=} interval
         * @return {?}
         */
        SliderComponent.prototype.subscribeInputModelChangeSubject = /**
         * @param {?=} interval
         * @return {?}
         */
            function (interval) {
                var _this = this;
                this.inputModelChangeSubscription = this.inputModelChangeSubject
                    .pipe(operators.distinctUntilChanged(ModelChange.compare), 
                // Hack to reset the status of the distinctUntilChanged() - if a "fake" event comes through with forceChange=true,
                // we forcefully by-pass distinctUntilChanged(), but otherwise drop the event
                operators.filter(function (modelChange) { return !modelChange.forceChange && !modelChange.internalChange; }), (!ValueHelper.isNullOrUndefined(interval))
                    ? operators.throttleTime(interval, undefined, { leading: true, trailing: true })
                    : operators.tap(function () { }) // no-op
                )
                    .subscribe(function (modelChange) { return _this.applyInputModelChange(modelChange); });
            };
        /**
         * @param {?=} interval
         * @return {?}
         */
        SliderComponent.prototype.subscribeOutputModelChangeSubject = /**
         * @param {?=} interval
         * @return {?}
         */
            function (interval) {
                var _this = this;
                this.outputModelChangeSubscription = this.outputModelChangeSubject
                    .pipe(operators.distinctUntilChanged(ModelChange.compare), (!ValueHelper.isNullOrUndefined(interval))
                    ? operators.throttleTime(interval, undefined, { leading: true, trailing: true })
                    : operators.tap(function () { }) // no-op
                )
                    .subscribe(function (modelChange) { return _this.publishOutputModelChange(modelChange); });
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.subscribeResizeObserver = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (CompatibilityHelper.isResizeObserverAvailable()) {
                    this.resizeObserver = new ResizeObserver(function () { return _this.calculateViewDimensionsAndDetectChanges(); });
                    this.resizeObserver.observe(this.elementRef.nativeElement);
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.unsubscribeResizeObserver = /**
         * @return {?}
         */
            function () {
                if (CompatibilityHelper.isResizeObserverAvailable() && this.resizeObserver !== null) {
                    this.resizeObserver.disconnect();
                    this.resizeObserver = null;
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.unsubscribeOnMove = /**
         * @return {?}
         */
            function () {
                if (!ValueHelper.isNullOrUndefined(this.onMoveEventListener)) {
                    this.eventListenerHelper.detachEventListener(this.onMoveEventListener);
                    this.onMoveEventListener = null;
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.unsubscribeOnEnd = /**
         * @return {?}
         */
            function () {
                if (!ValueHelper.isNullOrUndefined(this.onEndEventListener)) {
                    this.eventListenerHelper.detachEventListener(this.onEndEventListener);
                    this.onEndEventListener = null;
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.unsubscribeInputModelChangeSubject = /**
         * @return {?}
         */
            function () {
                if (!ValueHelper.isNullOrUndefined(this.inputModelChangeSubscription)) {
                    this.inputModelChangeSubscription.unsubscribe();
                    this.inputModelChangeSubscription = null;
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.unsubscribeOutputModelChangeSubject = /**
         * @return {?}
         */
            function () {
                if (!ValueHelper.isNullOrUndefined(this.outputModelChangeSubscription)) {
                    this.outputModelChangeSubscription.unsubscribe();
                    this.outputModelChangeSubscription = null;
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.unsubscribeManualRefresh = /**
         * @return {?}
         */
            function () {
                if (!ValueHelper.isNullOrUndefined(this.manualRefreshSubscription)) {
                    this.manualRefreshSubscription.unsubscribe();
                    this.manualRefreshSubscription = null;
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.unsubscribeTriggerFocus = /**
         * @return {?}
         */
            function () {
                if (!ValueHelper.isNullOrUndefined(this.triggerFocusSubscription)) {
                    this.triggerFocusSubscription.unsubscribe();
                    this.triggerFocusSubscription = null;
                }
            };
        /**
         * @param {?} pointerType
         * @return {?}
         */
        SliderComponent.prototype.getPointerElement = /**
         * @param {?} pointerType
         * @return {?}
         */
            function (pointerType) {
                if (pointerType === PointerType.Min) {
                    return this.minHandleElement;
                }
                else if (pointerType === PointerType.Max) {
                    return this.maxHandleElement;
                }
                return null;
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.getCurrentTrackingValue = /**
         * @return {?}
         */
            function () {
                if (this.currentTrackingPointer === PointerType.Min) {
                    return this.viewLowValue;
                }
                else if (this.currentTrackingPointer === PointerType.Max) {
                    return this.viewHighValue;
                }
                return null;
            };
        /**
         * @param {?} modelValue
         * @return {?}
         */
        SliderComponent.prototype.modelValueToViewValue = /**
         * @param {?} modelValue
         * @return {?}
         */
            function (modelValue) {
                if (ValueHelper.isNullOrUndefined(modelValue)) {
                    return NaN;
                }
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {
                    return ValueHelper.findStepIndex(+modelValue, this.viewOptions.stepsArray);
                }
                return +modelValue;
            };
        /**
         * @param {?} viewValue
         * @return {?}
         */
        SliderComponent.prototype.viewValueToModelValue = /**
         * @param {?} viewValue
         * @return {?}
         */
            function (viewValue) {
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {
                    return this.getStepValue(viewValue);
                }
                return viewValue;
            };
        /**
         * @param {?} sliderValue
         * @return {?}
         */
        SliderComponent.prototype.getStepValue = /**
         * @param {?} sliderValue
         * @return {?}
         */
            function (sliderValue) {
                /** @type {?} */
                var step = this.viewOptions.stepsArray[sliderValue];
                return (!ValueHelper.isNullOrUndefined(step)) ? step.value : NaN;
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.applyViewChange = /**
         * @return {?}
         */
            function () {
                this.value = this.viewValueToModelValue(this.viewLowValue);
                if (this.range) {
                    this.highValue = this.viewValueToModelValue(this.viewHighValue);
                }
                this.outputModelChangeSubject.next({
                    value: this.value,
                    highValue: this.highValue,
                    userEventInitiated: true,
                    forceChange: false
                });
                // At this point all changes are applied and outputs are emitted, so we should be done.
                // However, input changes are communicated in different stream and we need to be ready to
                // act on the next input change even if it is exactly the same as last input change.
                // Therefore, we send a special event to reset the stream.
                this.inputModelChangeSubject.next({
                    value: this.value,
                    highValue: this.highValue,
                    forceChange: false,
                    internalChange: true
                });
            };
        /**
         * @param {?} modelChange
         * @return {?}
         */
        SliderComponent.prototype.applyInputModelChange = /**
         * @param {?} modelChange
         * @return {?}
         */
            function (modelChange) {
                /** @type {?} */
                var normalisedModelChange = this.normaliseModelValues(modelChange);
                /** @type {?} */
                var normalisationChange = !ModelValues.compare(modelChange, normalisedModelChange);
                if (normalisationChange) {
                    this.value = normalisedModelChange.value;
                    this.highValue = normalisedModelChange.highValue;
                }
                this.viewLowValue = this.modelValueToViewValue(normalisedModelChange.value);
                if (this.range) {
                    this.viewHighValue = this.modelValueToViewValue(normalisedModelChange.highValue);
                }
                else {
                    this.viewHighValue = null;
                }
                this.updateLowHandle(this.valueToPosition(this.viewLowValue));
                if (this.range) {
                    this.updateHighHandle(this.valueToPosition(this.viewHighValue));
                }
                this.updateSelectionBar();
                this.updateTicksScale();
                this.updateAriaAttributes();
                if (this.range) {
                    this.updateCombinedLabel();
                }
                // At the end, we need to communicate the model change to the outputs as well
                // Normalisation changes are also always forced out to ensure that subscribers always end up in correct state
                this.outputModelChangeSubject.next({
                    value: normalisedModelChange.value,
                    highValue: normalisedModelChange.highValue,
                    forceChange: normalisationChange,
                    userEventInitiated: false
                });
            };
        /**
         * @param {?} modelChange
         * @return {?}
         */
        SliderComponent.prototype.publishOutputModelChange = /**
         * @param {?} modelChange
         * @return {?}
         */
            function (modelChange) {
                var _this = this;
                /** @type {?} */
                var emitOutputs = function () {
                    _this.valueChange.emit(modelChange.value);
                    if (_this.range) {
                        _this.highValueChange.emit(modelChange.highValue);
                    }
                    if (!ValueHelper.isNullOrUndefined(_this.onChangeCallback)) {
                        if (_this.range) {
                            _this.onChangeCallback([modelChange.value, modelChange.highValue]);
                        }
                        else {
                            _this.onChangeCallback(modelChange.value);
                        }
                    }
                    if (!ValueHelper.isNullOrUndefined(_this.onTouchedCallback)) {
                        if (_this.range) {
                            _this.onTouchedCallback([modelChange.value, modelChange.highValue]);
                        }
                        else {
                            _this.onTouchedCallback(modelChange.value);
                        }
                    }
                };
                if (modelChange.userEventInitiated) {
                    // If this change was initiated by a user event, we can emit outputs in the same tick
                    emitOutputs();
                    this.userChange.emit(this.getChangeContext());
                }
                else {
                    // But, if the change was initated by something else like a change in input bindings,
                    // we need to wait until next tick to emit the outputs to keep Angular change detection happy
                    setTimeout(function () { emitOutputs(); });
                }
            };
        /**
         * @param {?} input
         * @return {?}
         */
        SliderComponent.prototype.normaliseModelValues = /**
         * @param {?} input
         * @return {?}
         */
            function (input) {
                /** @type {?} */
                var normalisedInput = new ModelValues();
                normalisedInput.value = input.value;
                normalisedInput.highValue = input.highValue;
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray)) {
                    // When using steps array, only round to nearest step in the array
                    // No other enforcement can be done, as the step array may be out of order, and that is perfectly fine
                    if (this.viewOptions.enforceStepsArray) {
                        /** @type {?} */
                        var valueIndex = ValueHelper.findStepIndex(normalisedInput.value, this.viewOptions.stepsArray);
                        normalisedInput.value = this.viewOptions.stepsArray[valueIndex].value;
                        if (this.range) {
                            /** @type {?} */
                            var highValueIndex = ValueHelper.findStepIndex(normalisedInput.highValue, this.viewOptions.stepsArray);
                            normalisedInput.highValue = this.viewOptions.stepsArray[highValueIndex].value;
                        }
                    }
                    return normalisedInput;
                }
                if (this.viewOptions.enforceStep) {
                    normalisedInput.value = this.roundStep(normalisedInput.value);
                    if (this.range) {
                        normalisedInput.highValue = this.roundStep(normalisedInput.highValue);
                    }
                }
                if (this.viewOptions.enforceRange) {
                    normalisedInput.value = MathHelper.clampToRange(normalisedInput.value, this.viewOptions.floor, this.viewOptions.ceil);
                    if (this.range) {
                        normalisedInput.highValue = MathHelper.clampToRange(normalisedInput.highValue, this.viewOptions.floor, this.viewOptions.ceil);
                    }
                    // Make sure that range slider invariant (value <= highValue) is always satisfied
                    if (this.range && input.value > input.highValue) {
                        // We know that both values are now clamped correctly, they may just be in the wrong order
                        // So the easy solution is to swap them... except swapping is sometimes disabled in options, so we make the two values the same
                        if (this.viewOptions.noSwitching) {
                            normalisedInput.value = normalisedInput.highValue;
                        }
                        else {
                            /** @type {?} */
                            var tempValue = input.value;
                            normalisedInput.value = input.highValue;
                            normalisedInput.highValue = tempValue;
                        }
                    }
                }
                return normalisedInput;
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.renormaliseModelValues = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var previousModelValues = {
                    value: this.value,
                    highValue: this.highValue
                };
                /** @type {?} */
                var normalisedModelValues = this.normaliseModelValues(previousModelValues);
                if (!ModelValues.compare(normalisedModelValues, previousModelValues)) {
                    this.value = normalisedModelValues.value;
                    this.highValue = normalisedModelValues.highValue;
                    this.outputModelChangeSubject.next({
                        value: this.value,
                        highValue: this.highValue,
                        forceChange: true,
                        userEventInitiated: false
                    });
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.onChangeOptions = /**
         * @return {?}
         */
            function () {
                if (!this.initHasRun) {
                    return;
                }
                /** @type {?} */
                var previousInputEventsInterval = this.viewOptions.inputEventsInterval;
                /** @type {?} */
                var previousOutputEventsInterval = this.viewOptions.outputEventsInterval;
                /** @type {?} */
                var previousOptionsInfluencingEventBindings = this.getOptionsInfluencingEventBindings(this.viewOptions);
                this.applyOptions();
                /** @type {?} */
                var newOptionsInfluencingEventBindings = this.getOptionsInfluencingEventBindings(this.viewOptions);
                /** @type {?} */
                var rebindEvents = !ValueHelper.areArraysEqual(previousOptionsInfluencingEventBindings, newOptionsInfluencingEventBindings);
                if (previousInputEventsInterval !== this.viewOptions.inputEventsInterval) {
                    this.unsubscribeInputModelChangeSubject();
                    this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval);
                }
                if (previousOutputEventsInterval !== this.viewOptions.outputEventsInterval) {
                    this.unsubscribeInputModelChangeSubject();
                    this.subscribeInputModelChangeSubject(this.viewOptions.outputEventsInterval);
                }
                // With new options, we need to re-normalise model values if necessary
                this.renormaliseModelValues();
                this.viewLowValue = this.modelValueToViewValue(this.value);
                if (this.range) {
                    this.viewHighValue = this.modelValueToViewValue(this.highValue);
                }
                else {
                    this.viewHighValue = null;
                }
                this.resetSlider(rebindEvents);
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.applyOptions = /**
         * @return {?}
         */
            function () {
                this.viewOptions = new Options();
                Object.assign(this.viewOptions, this.options);
                this.viewOptions.draggableRange = this.range && this.viewOptions.draggableRange;
                this.viewOptions.draggableRangeOnly = this.range && this.viewOptions.draggableRangeOnly;
                if (this.viewOptions.draggableRangeOnly) {
                    this.viewOptions.draggableRange = true;
                }
                this.viewOptions.showTicks = this.viewOptions.showTicks ||
                    this.viewOptions.showTicksValues ||
                    !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray);
                if (this.viewOptions.showTicks &&
                    (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) || !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray))) {
                    this.intermediateTicks = true;
                }
                this.viewOptions.showSelectionBar = this.viewOptions.showSelectionBar ||
                    this.viewOptions.showSelectionBarEnd ||
                    !ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue);
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray)) {
                    this.applyStepsArrayOptions();
                }
                else {
                    this.applyFloorCeilOptions();
                }
                if (ValueHelper.isNullOrUndefined(this.viewOptions.combineLabels)) {
                    this.viewOptions.combineLabels = function (minValue, maxValue) {
                        return minValue + ' - ' + maxValue;
                    };
                }
                if (this.viewOptions.logScale && this.viewOptions.floor === 0) {
                    throw Error('Can\'t use floor=0 with logarithmic scale');
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.applyStepsArrayOptions = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.viewOptions.floor = 0;
                this.viewOptions.ceil = this.viewOptions.stepsArray.length - 1;
                this.viewOptions.step = 1;
                if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {
                    this.viewOptions.translate = function (modelValue) {
                        if (_this.viewOptions.bindIndexForStepsArray) {
                            return String(_this.getStepValue(modelValue));
                        }
                        return String(modelValue);
                    };
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.applyFloorCeilOptions = /**
         * @return {?}
         */
            function () {
                if (ValueHelper.isNullOrUndefined(this.viewOptions.step)) {
                    this.viewOptions.step = 1;
                }
                else {
                    this.viewOptions.step = +this.viewOptions.step;
                    if (this.viewOptions.step <= 0) {
                        this.viewOptions.step = 1;
                    }
                }
                if (ValueHelper.isNullOrUndefined(this.viewOptions.ceil) ||
                    ValueHelper.isNullOrUndefined(this.viewOptions.floor)) {
                    throw Error('floor and ceil options must be supplied');
                }
                this.viewOptions.ceil = +this.viewOptions.ceil;
                this.viewOptions.floor = +this.viewOptions.floor;
                if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {
                    this.viewOptions.translate = function (value) { return String(value); };
                }
            };
        /**
         * @param {?=} rebindEvents
         * @return {?}
         */
        SliderComponent.prototype.resetSlider = /**
         * @param {?=} rebindEvents
         * @return {?}
         */
            function (rebindEvents) {
                if (rebindEvents === void 0) {
                    rebindEvents = true;
                }
                this.manageElementsStyle();
                this.addAccessibility();
                this.updateCeilLabel();
                this.updateFloorLabel();
                if (rebindEvents) {
                    this.unbindEvents();
                    this.manageEventsBindings();
                }
                this.updateDisabledState();
                this.calculateViewDimensions();
                this.refocusPointerIfNeeded();
            };
        /**
         * @param {?} pointerType
         * @return {?}
         */
        SliderComponent.prototype.focusPointer = /**
         * @param {?} pointerType
         * @return {?}
         */
            function (pointerType) {
                // If not supplied, use min pointer as default
                if (pointerType !== PointerType.Min && pointerType !== PointerType.Max) {
                    pointerType = PointerType.Min;
                }
                if (pointerType === PointerType.Min) {
                    this.minHandleElement.focus();
                }
                else if (this.range && pointerType === PointerType.Max) {
                    this.maxHandleElement.focus();
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.refocusPointerIfNeeded = /**
         * @return {?}
         */
            function () {
                if (!ValueHelper.isNullOrUndefined(this.currentFocusPointer)) {
                    this.onPointerFocus(this.currentFocusPointer);
                    /** @type {?} */
                    var element = this.getPointerElement(this.currentFocusPointer);
                    element.focus();
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.manageElementsStyle = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.updateScale();
                this.floorLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);
                this.ceilLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);
                /** @type {?} */
                var hideLabelsForTicks = this.viewOptions.showTicksValues && !this.intermediateTicks;
                this.minHandleLabelElement.setAlwaysHide(hideLabelsForTicks || this.viewOptions.hidePointerLabels);
                this.maxHandleLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);
                this.combinedLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);
                this.selectionBarElement.setAlwaysHide(!this.range && !this.viewOptions.showSelectionBar);
                this.leftOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);
                this.rightOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);
                this.fullBarTransparentClass = this.range && this.viewOptions.showOuterSelectionBars;
                this.selectionBarDraggableClass = this.viewOptions.draggableRange && !this.viewOptions.onlyBindHandles;
                this.ticksUnderValuesClass = this.intermediateTicks && this.options.showTicksValues;
                if (this.sliderElementVerticalClass !== this.viewOptions.vertical) {
                    this.updateVerticalState();
                    // The above change in host component class will not be applied until the end of this cycle
                    // However, functions calculating the slider position expect the slider to be already styled as vertical
                    // So as a workaround, we need to reset the slider once again to compute the correct values
                    setTimeout(function () { _this.resetSlider(); });
                }
                // Changing animate class may interfere with slider reset/initialisation, so we should set it separately,
                // after all is properly set up
                if (this.sliderElementAnimateClass !== this.viewOptions.animate) {
                    setTimeout(function () { _this.sliderElementAnimateClass = _this.viewOptions.animate; });
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.manageEventsBindings = /**
         * @return {?}
         */
            function () {
                if (this.viewOptions.disabled || this.viewOptions.readOnly) {
                    this.unbindEvents();
                }
                else {
                    this.bindEvents();
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateDisabledState = /**
         * @return {?}
         */
            function () {
                this.sliderElementDisabledAttr = this.viewOptions.disabled ? 'disabled' : null;
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateVerticalState = /**
         * @return {?}
         */
            function () {
                this.sliderElementVerticalClass = this.viewOptions.vertical;
                try {
                    for (var _a = __values(this.getAllSliderElements()), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var element = _b.value;
                        // This is also called before ngAfterInit, so need to check that view child bindings work
                        if (!ValueHelper.isNullOrUndefined(element)) {
                            element.setVertical(this.viewOptions.vertical);
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                var e_1, _c;
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateScale = /**
         * @return {?}
         */
            function () {
                try {
                    for (var _a = __values(this.getAllSliderElements()), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var element = _b.value;
                        element.setScale(this.viewOptions.scale);
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                var e_2, _c;
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.getAllSliderElements = /**
         * @return {?}
         */
            function () {
                return [this.leftOuterSelectionBarElement,
                    this.rightOuterSelectionBarElement,
                    this.fullBarElement,
                    this.selectionBarElement,
                    this.minHandleElement,
                    this.maxHandleElement,
                    this.floorLabelElement,
                    this.ceilLabelElement,
                    this.minHandleLabelElement,
                    this.maxHandleLabelElement,
                    this.combinedLabelElement,
                    this.ticksElement
                ];
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.initHandles = /**
         * @return {?}
         */
            function () {
                this.updateLowHandle(this.valueToPosition(this.viewLowValue));
                /*
                   the order here is important since the selection bar should be
                   updated after the high handle but before the combined label
                   */
                if (this.range) {
                    this.updateHighHandle(this.valueToPosition(this.viewHighValue));
                }
                this.updateSelectionBar();
                if (this.range) {
                    this.updateCombinedLabel();
                }
                this.updateTicksScale();
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.addAccessibility = /**
         * @return {?}
         */
            function () {
                this.updateAriaAttributes();
                this.minHandleElement.role = 'slider';
                if (this.viewOptions.keyboardSupport &&
                    !(this.viewOptions.readOnly || this.viewOptions.disabled)) {
                    this.minHandleElement.tabindex = '0';
                }
                else {
                    this.minHandleElement.tabindex = '';
                }
                this.minHandleElement.ariaOrientation = this.viewOptions.vertical ? 'vertical' : 'horizontal';
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabel)) {
                    this.minHandleElement.ariaLabel = this.viewOptions.ariaLabel;
                }
                else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledBy)) {
                    this.minHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledBy;
                }
                if (this.range) {
                    this.maxHandleElement.role = 'slider';
                    if (this.viewOptions.keyboardSupport &&
                        !(this.viewOptions.readOnly || this.viewOptions.disabled)) {
                        this.maxHandleElement.tabindex = '0';
                    }
                    else {
                        this.maxHandleElement.tabindex = '';
                    }
                    this.maxHandleElement.ariaOrientation = this.viewOptions.vertical ? 'vertical' : 'horizontal';
                    if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelHigh)) {
                        this.maxHandleElement.ariaLabel = this.viewOptions.ariaLabelHigh;
                    }
                    else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledByHigh)) {
                        this.maxHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledByHigh;
                    }
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateAriaAttributes = /**
         * @return {?}
         */
            function () {
                this.minHandleElement.ariaValueNow = (+this.value).toString();
                this.minHandleElement.ariaValueText = this.viewOptions.translate(+this.value, LabelType.Low);
                this.minHandleElement.ariaValueMin = this.viewOptions.floor.toString();
                this.minHandleElement.ariaValueMax = this.viewOptions.ceil.toString();
                if (this.range) {
                    this.maxHandleElement.ariaValueNow = (+this.highValue).toString();
                    this.maxHandleElement.ariaValueText = this.viewOptions.translate(+this.highValue, LabelType.High);
                    this.maxHandleElement.ariaValueMin = this.viewOptions.floor.toString();
                    this.maxHandleElement.ariaValueMax = this.viewOptions.ceil.toString();
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.calculateViewDimensions = /**
         * @return {?}
         */
            function () {
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.handleDimension)) {
                    this.minHandleElement.setDimension(this.viewOptions.handleDimension);
                }
                else {
                    this.minHandleElement.calculateDimension();
                }
                /** @type {?} */
                var handleWidth = this.minHandleElement.dimension;
                this.handleHalfDimension = handleWidth / 2;
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.barDimension)) {
                    this.fullBarElement.setDimension(this.viewOptions.barDimension);
                }
                else {
                    this.fullBarElement.calculateDimension();
                }
                this.maxHandlePosition = this.fullBarElement.dimension - handleWidth;
                if (this.initHasRun) {
                    this.updateFloorLabel();
                    this.updateCeilLabel();
                    this.initHandles();
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.calculateViewDimensionsAndDetectChanges = /**
         * @return {?}
         */
            function () {
                this.calculateViewDimensions();
                if (!this.isRefDestroyed()) {
                    this.changeDetectionRef.detectChanges();
                }
            };
        /**
         * If the slider reference is already destroyed
         * @return {?} boolean - true if ref is destroyed
         */
        SliderComponent.prototype.isRefDestroyed = /**
         * If the slider reference is already destroyed
         * @return {?} boolean - true if ref is destroyed
         */
            function () {
                return this.changeDetectionRef['destroyed'];
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateTicksScale = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.viewOptions.showTicks) {
                    setTimeout(function () { _this.sliderElementWithLegendClass = false; });
                    return;
                }
                /** @type {?} */
                var ticksArray = !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray)
                    ? this.viewOptions.ticksArray
                    : this.getTicksArray();
                /** @type {?} */
                var translate = this.viewOptions.vertical ? 'translateY' : 'translateX';
                if (this.viewOptions.rightToLeft) {
                    ticksArray.reverse();
                }
                /** @type {?} */
                var tickValueStep = !ValueHelper.isNullOrUndefined(this.viewOptions.tickValueStep) ? this.viewOptions.tickValueStep :
                    (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) ? this.viewOptions.tickStep : this.viewOptions.step);
                /** @type {?} */
                var hasAtLeastOneLegend = false;
                /** @type {?} */
                var newTicks = ticksArray.map(function (value) {
                    /** @type {?} */
                    var position = _this.valueToPosition(value);
                    if (_this.viewOptions.vertical) {
                        position = _this.maxHandlePosition - position;
                    }
                    /** @type {?} */
                    var translation = translate + '(' + Math.round(position) + 'px)';
                    /** @type {?} */
                    var tick = new Tick();
                    tick.selected = _this.isTickSelected(value);
                    tick.style = {
                        '-webkit-transform': translation,
                        '-moz-transform': translation,
                        '-o-transform': translation,
                        '-ms-transform': translation,
                        transform: translation,
                    };
                    if (tick.selected && !ValueHelper.isNullOrUndefined(_this.viewOptions.getSelectionBarColor)) {
                        tick.style['background-color'] = _this.getSelectionBarColor();
                    }
                    if (!tick.selected && !ValueHelper.isNullOrUndefined(_this.viewOptions.getTickColor)) {
                        tick.style['background-color'] = _this.getTickColor(value);
                    }
                    if (!ValueHelper.isNullOrUndefined(_this.viewOptions.ticksTooltip)) {
                        tick.tooltip = _this.viewOptions.ticksTooltip(value);
                        tick.tooltipPlacement = _this.viewOptions.vertical ? 'right' : 'top';
                    }
                    if (_this.viewOptions.showTicksValues && !ValueHelper.isNullOrUndefined(tickValueStep) &&
                        MathHelper.isModuloWithinPrecisionLimit(value, tickValueStep, _this.viewOptions.precisionLimit)) {
                        tick.value = _this.getDisplayValue(value, LabelType.TickValue);
                        if (!ValueHelper.isNullOrUndefined(_this.viewOptions.ticksValuesTooltip)) {
                            tick.valueTooltip = _this.viewOptions.ticksValuesTooltip(value);
                            tick.valueTooltipPlacement = _this.viewOptions.vertical
                                ? 'right'
                                : 'top';
                        }
                    }
                    /** @type {?} */
                    var legend = null;
                    if (!ValueHelper.isNullOrUndefined(_this.viewOptions.stepsArray)) {
                        /** @type {?} */
                        var step = _this.viewOptions.stepsArray[value];
                        if (!ValueHelper.isNullOrUndefined(step)) {
                            legend = step.legend;
                        }
                    }
                    else if (!ValueHelper.isNullOrUndefined(_this.viewOptions.getLegend)) {
                        legend = _this.viewOptions.getLegend(value);
                    }
                    if (!ValueHelper.isNullOrUndefined(legend)) {
                        tick.legend = legend;
                        hasAtLeastOneLegend = true;
                    }
                    return tick;
                });
                setTimeout(function () { _this.sliderElementWithLegendClass = hasAtLeastOneLegend; });
                // We should avoid re-creating the ticks array if possible
                // This both improves performance and makes CSS animations work correctly
                if (!ValueHelper.isNullOrUndefined(this.ticks) && this.ticks.length === newTicks.length) {
                    for (var i = 0; i < newTicks.length; ++i) {
                        Object.assign(this.ticks[i], newTicks[i]);
                    }
                }
                else {
                    this.ticks = newTicks;
                }
                if (!this.isRefDestroyed()) {
                    this.changeDetectionRef.detectChanges();
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.getTicksArray = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var step = (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep)) ? this.viewOptions.tickStep : this.viewOptions.step;
                /** @type {?} */
                var ticksArray = [];
                /** @type {?} */
                var numberOfValues = 1 + Math.floor(MathHelper.roundToPrecisionLimit(Math.abs(this.viewOptions.ceil - this.viewOptions.floor) / step, this.viewOptions.precisionLimit));
                for (var index = 0; index < numberOfValues; ++index) {
                    ticksArray.push(MathHelper.roundToPrecisionLimit(this.viewOptions.floor + step * index, this.viewOptions.precisionLimit));
                }
                return ticksArray;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.isTickSelected = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (!this.range) {
                    if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {
                        /** @type {?} */
                        var center = this.viewOptions.showSelectionBarFromValue;
                        if (this.viewLowValue > center &&
                            value >= center &&
                            value <= this.viewLowValue) {
                            return true;
                        }
                        else if (this.viewLowValue < center &&
                            value <= center &&
                            value >= this.viewLowValue) {
                            return true;
                        }
                    }
                    else if (this.viewOptions.showSelectionBarEnd) {
                        if (value >= this.viewLowValue) {
                            return true;
                        }
                    }
                    else if (this.viewOptions.showSelectionBar && value <= this.viewLowValue) {
                        return true;
                    }
                }
                if (this.range && value >= this.viewLowValue && value <= this.viewHighValue) {
                    return true;
                }
                return false;
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateFloorLabel = /**
         * @return {?}
         */
            function () {
                if (!this.floorLabelElement.alwaysHide) {
                    this.floorLabelElement.setValue(this.getDisplayValue(this.viewOptions.floor, LabelType.Floor));
                    this.floorLabelElement.calculateDimension();
                    /** @type {?} */
                    var position = this.viewOptions.rightToLeft
                        ? this.fullBarElement.dimension - this.floorLabelElement.dimension
                        : 0;
                    this.floorLabelElement.setPosition(position);
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateCeilLabel = /**
         * @return {?}
         */
            function () {
                if (!this.ceilLabelElement.alwaysHide) {
                    this.ceilLabelElement.setValue(this.getDisplayValue(this.viewOptions.ceil, LabelType.Ceil));
                    this.ceilLabelElement.calculateDimension();
                    /** @type {?} */
                    var position = this.viewOptions.rightToLeft
                        ? 0
                        : this.fullBarElement.dimension - this.ceilLabelElement.dimension;
                    this.ceilLabelElement.setPosition(position);
                }
            };
        /**
         * @param {?} which
         * @param {?} newPos
         * @return {?}
         */
        SliderComponent.prototype.updateHandles = /**
         * @param {?} which
         * @param {?} newPos
         * @return {?}
         */
            function (which, newPos) {
                if (which === PointerType.Min) {
                    this.updateLowHandle(newPos);
                }
                else if (which === PointerType.Max) {
                    this.updateHighHandle(newPos);
                }
                this.updateSelectionBar();
                this.updateTicksScale();
                if (this.range) {
                    this.updateCombinedLabel();
                }
            };
        /**
         * @param {?} labelType
         * @param {?} newPos
         * @return {?}
         */
        SliderComponent.prototype.getHandleLabelPos = /**
         * @param {?} labelType
         * @param {?} newPos
         * @return {?}
         */
            function (labelType, newPos) {
                /** @type {?} */
                var labelDimension = (labelType === PointerType.Min)
                    ? this.minHandleLabelElement.dimension
                    : this.maxHandleLabelElement.dimension;
                /** @type {?} */
                var nearHandlePos = newPos - labelDimension / 2 + this.handleHalfDimension;
                /** @type {?} */
                var endOfBarPos = this.fullBarElement.dimension - labelDimension;
                if (!this.viewOptions.boundPointerLabels) {
                    return nearHandlePos;
                }
                if ((this.viewOptions.rightToLeft && labelType === PointerType.Min) ||
                    (!this.viewOptions.rightToLeft && labelType === PointerType.Max)) {
                    return Math.min(nearHandlePos, endOfBarPos);
                }
                else {
                    return Math.min(Math.max(nearHandlePos, 0), endOfBarPos);
                }
            };
        /**
         * @param {?} newPos
         * @return {?}
         */
        SliderComponent.prototype.updateLowHandle = /**
         * @param {?} newPos
         * @return {?}
         */
            function (newPos) {
                this.minHandleElement.setPosition(newPos);
                this.minHandleLabelElement.setValue(this.getDisplayValue(this.viewLowValue, LabelType.Low));
                this.minHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Min, newPos));
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {
                    this.minPointerStyle = {
                        backgroundColor: this.getPointerColor(PointerType.Min),
                    };
                }
                if (this.viewOptions.autoHideLimitLabels) {
                    this.updateFloorAndCeilLabelsVisibility();
                }
            };
        /**
         * @param {?} newPos
         * @return {?}
         */
        SliderComponent.prototype.updateHighHandle = /**
         * @param {?} newPos
         * @return {?}
         */
            function (newPos) {
                this.maxHandleElement.setPosition(newPos);
                this.maxHandleLabelElement.setValue(this.getDisplayValue(this.viewHighValue, LabelType.High));
                this.maxHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Max, newPos));
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {
                    this.maxPointerStyle = {
                        backgroundColor: this.getPointerColor(PointerType.Max),
                    };
                }
                if (this.viewOptions.autoHideLimitLabels) {
                    this.updateFloorAndCeilLabelsVisibility();
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateFloorAndCeilLabelsVisibility = /**
         * @return {?}
         */
            function () {
                // Show based only on hideLimitLabels if pointer labels are hidden
                if (this.viewOptions.hidePointerLabels) {
                    return;
                }
                /** @type {?} */
                var floorLabelHidden = false;
                /** @type {?} */
                var ceilLabelHidden = false;
                /** @type {?} */
                var isMinLabelAtFloor = this.isLabelBelowFloorLabel(this.minHandleLabelElement);
                /** @type {?} */
                var isMinLabelAtCeil = this.isLabelAboveCeilLabel(this.minHandleLabelElement);
                /** @type {?} */
                var isMaxLabelAtCeil = this.isLabelAboveCeilLabel(this.maxHandleLabelElement);
                /** @type {?} */
                var isCombinedLabelAtFloor = this.isLabelBelowFloorLabel(this.combinedLabelElement);
                /** @type {?} */
                var isCombinedLabelAtCeil = this.isLabelAboveCeilLabel(this.combinedLabelElement);
                if (isMinLabelAtFloor) {
                    floorLabelHidden = true;
                    this.floorLabelElement.hide();
                }
                else {
                    floorLabelHidden = false;
                    this.floorLabelElement.show();
                }
                if (isMinLabelAtCeil) {
                    ceilLabelHidden = true;
                    this.ceilLabelElement.hide();
                }
                else {
                    ceilLabelHidden = false;
                    this.ceilLabelElement.show();
                }
                if (this.range) {
                    /** @type {?} */
                    var hideCeil = this.combinedLabelElement.isVisible() ? isCombinedLabelAtCeil : isMaxLabelAtCeil;
                    /** @type {?} */
                    var hideFloor = this.combinedLabelElement.isVisible() ? isCombinedLabelAtFloor : isMinLabelAtFloor;
                    if (hideCeil) {
                        this.ceilLabelElement.hide();
                    }
                    else if (!ceilLabelHidden) {
                        this.ceilLabelElement.show();
                    }
                    // Hide or show floor label
                    if (hideFloor) {
                        this.floorLabelElement.hide();
                    }
                    else if (!floorLabelHidden) {
                        this.floorLabelElement.show();
                    }
                }
            };
        /**
         * @param {?} label
         * @return {?}
         */
        SliderComponent.prototype.isLabelBelowFloorLabel = /**
         * @param {?} label
         * @return {?}
         */
            function (label) {
                /** @type {?} */
                var pos = label.position;
                /** @type {?} */
                var dim = label.dimension;
                /** @type {?} */
                var floorPos = this.floorLabelElement.position;
                /** @type {?} */
                var floorDim = this.floorLabelElement.dimension;
                return this.viewOptions.rightToLeft
                    ? pos + dim >= floorPos - 2
                    : pos <= floorPos + floorDim + 2;
            };
        /**
         * @param {?} label
         * @return {?}
         */
        SliderComponent.prototype.isLabelAboveCeilLabel = /**
         * @param {?} label
         * @return {?}
         */
            function (label) {
                /** @type {?} */
                var pos = label.position;
                /** @type {?} */
                var dim = label.dimension;
                /** @type {?} */
                var ceilPos = this.ceilLabelElement.position;
                /** @type {?} */
                var ceilDim = this.ceilLabelElement.dimension;
                return this.viewOptions.rightToLeft
                    ? pos <= ceilPos + ceilDim + 2
                    : pos + dim >= ceilPos - 2;
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateSelectionBar = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var position = 0;
                /** @type {?} */
                var dimension = 0;
                /** @type {?} */
                var isSelectionBarFromRight = this.viewOptions.rightToLeft
                    ? !this.viewOptions.showSelectionBarEnd
                    : this.viewOptions.showSelectionBarEnd;
                /** @type {?} */
                var positionForRange = this.viewOptions.rightToLeft
                    ? this.maxHandleElement.position + this.handleHalfDimension
                    : this.minHandleElement.position + this.handleHalfDimension;
                if (this.range) {
                    dimension = Math.abs(this.maxHandleElement.position - this.minHandleElement.position);
                    position = positionForRange;
                }
                else {
                    if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {
                        /** @type {?} */
                        var center = this.viewOptions.showSelectionBarFromValue;
                        /** @type {?} */
                        var centerPosition = this.valueToPosition(center);
                        /** @type {?} */
                        var isModelGreaterThanCenter = this.viewOptions.rightToLeft
                            ? this.viewLowValue <= center
                            : this.viewLowValue > center;
                        if (isModelGreaterThanCenter) {
                            dimension = this.minHandleElement.position - centerPosition;
                            position = centerPosition + this.handleHalfDimension;
                        }
                        else {
                            dimension = centerPosition - this.minHandleElement.position;
                            position = this.minHandleElement.position + this.handleHalfDimension;
                        }
                    }
                    else if (isSelectionBarFromRight) {
                        dimension = Math.ceil(Math.abs(this.maxHandlePosition - this.minHandleElement.position) + this.handleHalfDimension);
                        position = Math.floor(this.minHandleElement.position + this.handleHalfDimension);
                    }
                    else {
                        dimension = this.minHandleElement.position + this.handleHalfDimension;
                        position = 0;
                    }
                }
                this.selectionBarElement.setDimension(dimension);
                this.selectionBarElement.setPosition(position);
                if (this.range && this.viewOptions.showOuterSelectionBars) {
                    if (this.viewOptions.rightToLeft) {
                        this.rightOuterSelectionBarElement.setDimension(position);
                        this.rightOuterSelectionBarElement.setPosition(0);
                        this.fullBarElement.calculateDimension();
                        this.leftOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));
                        this.leftOuterSelectionBarElement.setPosition(position + dimension);
                    }
                    else {
                        this.leftOuterSelectionBarElement.setDimension(position);
                        this.leftOuterSelectionBarElement.setPosition(0);
                        this.fullBarElement.calculateDimension();
                        this.rightOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));
                        this.rightOuterSelectionBarElement.setPosition(position + dimension);
                    }
                }
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.getSelectionBarColor)) {
                    /** @type {?} */
                    var color = this.getSelectionBarColor();
                    this.barStyle = {
                        backgroundColor: color,
                    };
                }
                else if (!ValueHelper.isNullOrUndefined(this.viewOptions.selectionBarGradient)) {
                    /** @type {?} */
                    var offset = (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue))
                        ? this.valueToPosition(this.viewOptions.showSelectionBarFromValue)
                        : 0;
                    /** @type {?} */
                    var reversed = (offset - position > 0 && !isSelectionBarFromRight) || (offset - position <= 0 && isSelectionBarFromRight);
                    /** @type {?} */
                    var direction = this.viewOptions.vertical
                        ? reversed ? 'bottom' : 'top'
                        : reversed ? 'left' : 'right';
                    this.barStyle = {
                        backgroundImage: 'linear-gradient(to ' +
                            direction +
                            ', ' +
                            this.viewOptions.selectionBarGradient.from +
                            ' 0%,' +
                            this.viewOptions.selectionBarGradient.to +
                            ' 100%)',
                    };
                    if (this.viewOptions.vertical) {
                        this.barStyle.backgroundPosition =
                            'center ' +
                                (offset +
                                    dimension +
                                    position +
                                    (reversed ? -this.handleHalfDimension : 0)) +
                                'px';
                        this.barStyle.backgroundSize =
                            '100% ' + (this.fullBarElement.dimension - this.handleHalfDimension) + 'px';
                    }
                    else {
                        this.barStyle.backgroundPosition =
                            offset -
                                position +
                                (reversed ? this.handleHalfDimension : 0) +
                                'px center';
                        this.barStyle.backgroundSize =
                            this.fullBarElement.dimension - this.handleHalfDimension + 'px 100%';
                    }
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.getSelectionBarColor = /**
         * @return {?}
         */
            function () {
                if (this.range) {
                    return this.viewOptions.getSelectionBarColor(this.value, this.highValue);
                }
                return this.viewOptions.getSelectionBarColor(this.value);
            };
        /**
         * @param {?} pointerType
         * @return {?}
         */
        SliderComponent.prototype.getPointerColor = /**
         * @param {?} pointerType
         * @return {?}
         */
            function (pointerType) {
                if (pointerType === PointerType.Max) {
                    return this.viewOptions.getPointerColor(this.highValue, pointerType);
                }
                return this.viewOptions.getPointerColor(this.value, pointerType);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.getTickColor = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return this.viewOptions.getTickColor(value);
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateCombinedLabel = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var isLabelOverlap = null;
                if (this.viewOptions.rightToLeft) {
                    isLabelOverlap =
                        this.minHandleLabelElement.position - this.minHandleLabelElement.dimension - 10 <= this.maxHandleLabelElement.position;
                }
                else {
                    isLabelOverlap =
                        this.minHandleLabelElement.position + this.minHandleLabelElement.dimension + 10 >= this.maxHandleLabelElement.position;
                }
                if (isLabelOverlap) {
                    /** @type {?} */
                    var lowDisplayValue = this.getDisplayValue(this.viewLowValue, LabelType.Low);
                    /** @type {?} */
                    var highDisplayValue = this.getDisplayValue(this.viewHighValue, LabelType.High);
                    /** @type {?} */
                    var combinedLabelValue = this.viewOptions.rightToLeft
                        ? this.viewOptions.combineLabels(highDisplayValue, lowDisplayValue)
                        : this.viewOptions.combineLabels(lowDisplayValue, highDisplayValue);
                    this.combinedLabelElement.setValue(combinedLabelValue);
                    /** @type {?} */
                    var pos = this.viewOptions.boundPointerLabels
                        ? Math.min(Math.max(this.selectionBarElement.position +
                            this.selectionBarElement.dimension / 2 -
                            this.combinedLabelElement.dimension / 2, 0), this.fullBarElement.dimension - this.combinedLabelElement.dimension)
                        : this.selectionBarElement.position + this.selectionBarElement.dimension / 2 - this.combinedLabelElement.dimension / 2;
                    this.combinedLabelElement.setPosition(pos);
                    this.minHandleLabelElement.hide();
                    this.maxHandleLabelElement.hide();
                    this.combinedLabelElement.show();
                }
                else {
                    this.updateHighHandle(this.valueToPosition(this.viewHighValue));
                    this.updateLowHandle(this.valueToPosition(this.viewLowValue));
                    this.maxHandleLabelElement.show();
                    this.minHandleLabelElement.show();
                    this.combinedLabelElement.hide();
                }
                if (this.viewOptions.autoHideLimitLabels) {
                    this.updateFloorAndCeilLabelsVisibility();
                }
            };
        /**
         * @param {?} value
         * @param {?} which
         * @return {?}
         */
        SliderComponent.prototype.getDisplayValue = /**
         * @param {?} value
         * @param {?} which
         * @return {?}
         */
            function (value, which) {
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {
                    value = this.getStepValue(value);
                }
                return this.viewOptions.translate(value, which);
            };
        /**
         * @param {?} value
         * @param {?=} customStep
         * @return {?}
         */
        SliderComponent.prototype.roundStep = /**
         * @param {?} value
         * @param {?=} customStep
         * @return {?}
         */
            function (value, customStep) {
                /** @type {?} */
                var step = !ValueHelper.isNullOrUndefined(customStep) ? customStep : this.viewOptions.step;
                /** @type {?} */
                var steppedDifference = MathHelper.roundToPrecisionLimit((value - this.viewOptions.floor) / step, this.viewOptions.precisionLimit);
                steppedDifference = Math.round(steppedDifference) * step;
                return MathHelper.roundToPrecisionLimit(this.viewOptions.floor + steppedDifference, this.viewOptions.precisionLimit);
            };
        /**
         * @param {?} val
         * @return {?}
         */
        SliderComponent.prototype.valueToPosition = /**
         * @param {?} val
         * @return {?}
         */
            function (val) {
                /** @type {?} */
                var fn = ValueHelper.linearValueToPosition;
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.customValueToPosition)) {
                    fn = this.viewOptions.customValueToPosition;
                }
                else if (this.viewOptions.logScale) {
                    fn = ValueHelper.logValueToPosition;
                }
                val = MathHelper.clampToRange(val, this.viewOptions.floor, this.viewOptions.ceil);
                /** @type {?} */
                var percent = fn(val, this.viewOptions.floor, this.viewOptions.ceil);
                if (ValueHelper.isNullOrUndefined(percent)) {
                    percent = 0;
                }
                if (this.viewOptions.rightToLeft) {
                    percent = 1 - percent;
                }
                return percent * this.maxHandlePosition;
            };
        /**
         * @param {?} position
         * @return {?}
         */
        SliderComponent.prototype.positionToValue = /**
         * @param {?} position
         * @return {?}
         */
            function (position) {
                /** @type {?} */
                var percent = position / this.maxHandlePosition;
                if (this.viewOptions.rightToLeft) {
                    percent = 1 - percent;
                }
                /** @type {?} */
                var fn = ValueHelper.linearPositionToValue;
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.customPositionToValue)) {
                    fn = this.viewOptions.customPositionToValue;
                }
                else if (this.viewOptions.logScale) {
                    fn = ValueHelper.logPositionToValue;
                }
                /** @type {?} */
                var value = fn(percent, this.viewOptions.floor, this.viewOptions.ceil);
                return !ValueHelper.isNullOrUndefined(value) ? value : 0;
            };
        /**
         * @param {?} event
         * @param {?=} targetTouchId
         * @return {?}
         */
        SliderComponent.prototype.getEventXY = /**
         * @param {?} event
         * @param {?=} targetTouchId
         * @return {?}
         */
            function (event, targetTouchId) {
                if (event instanceof MouseEvent) {
                    return this.viewOptions.vertical ? event.clientY : event.clientX;
                }
                /** @type {?} */
                var touchIndex = 0;
                /** @type {?} */
                var touches = event.touches;
                if (!ValueHelper.isNullOrUndefined(targetTouchId)) {
                    for (var i = 0; i < touches.length; i++) {
                        if (touches[i].identifier === targetTouchId) {
                            touchIndex = i;
                            break;
                        }
                    }
                }
                // Return the target touch or if the target touch was not found in the event
                // returns the coordinates of the first touch
                return this.viewOptions.vertical ? touches[touchIndex].clientY : touches[touchIndex].clientX;
            };
        /**
         * @param {?} event
         * @param {?=} targetTouchId
         * @return {?}
         */
        SliderComponent.prototype.getEventPosition = /**
         * @param {?} event
         * @param {?=} targetTouchId
         * @return {?}
         */
            function (event, targetTouchId) {
                /** @type {?} */
                var sliderElementBoundingRect = this.elementRef.nativeElement.getBoundingClientRect();
                /** @type {?} */
                var sliderPos = this.viewOptions.vertical ?
                    sliderElementBoundingRect.bottom : sliderElementBoundingRect.left;
                /** @type {?} */
                var eventPos = 0;
                if (this.viewOptions.vertical) {
                    eventPos = -this.getEventXY(event, targetTouchId) + sliderPos;
                }
                else {
                    eventPos = this.getEventXY(event, targetTouchId) - sliderPos;
                }
                return eventPos * this.viewOptions.scale - this.handleHalfDimension;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SliderComponent.prototype.getNearestHandle = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.range) {
                    return PointerType.Min;
                }
                /** @type {?} */
                var position = this.getEventPosition(event);
                /** @type {?} */
                var distanceMin = Math.abs(position - this.minHandleElement.position);
                /** @type {?} */
                var distanceMax = Math.abs(position - this.maxHandleElement.position);
                if (distanceMin < distanceMax) {
                    return PointerType.Min;
                }
                else if (distanceMin > distanceMax) {
                    return PointerType.Max;
                }
                else if (!this.viewOptions.rightToLeft) {
                    // if event is at the same distance from min/max then if it's at left of minH, we return minH else maxH
                    return position < this.minHandleElement.position ? PointerType.Min : PointerType.Max;
                }
                // reverse in rtl
                return position > this.minHandleElement.position ? PointerType.Min : PointerType.Max;
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.bindEvents = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var draggableRange = this.viewOptions.draggableRange;
                if (!this.viewOptions.onlyBindHandles) {
                    this.selectionBarElement.on('mousedown', function (event) { return _this.onBarStart(null, draggableRange, event, true, true, true); });
                }
                if (this.viewOptions.draggableRangeOnly) {
                    this.minHandleElement.on('mousedown', function (event) { return _this.onBarStart(PointerType.Min, draggableRange, event, true, true); });
                    this.maxHandleElement.on('mousedown', function (event) { return _this.onBarStart(PointerType.Max, draggableRange, event, true, true); });
                }
                else {
                    this.minHandleElement.on('mousedown', function (event) { return _this.onStart(PointerType.Min, event, true, true); });
                    if (this.range) {
                        this.maxHandleElement.on('mousedown', function (event) { return _this.onStart(PointerType.Max, event, true, true); });
                    }
                    if (!this.viewOptions.onlyBindHandles) {
                        this.fullBarElement.on('mousedown', function (event) { return _this.onStart(null, event, true, true, true); });
                        this.ticksElement.on('mousedown', function (event) { return _this.onStart(null, event, true, true, true, true); });
                    }
                }
                if (!this.viewOptions.onlyBindHandles) {
                    this.selectionBarElement.onPassive('touchstart', function (event) { return _this.onBarStart(null, draggableRange, event, true, true, true); });
                }
                if (this.viewOptions.draggableRangeOnly) {
                    this.minHandleElement.onPassive('touchstart', function (event) { return _this.onBarStart(PointerType.Min, draggableRange, event, true, true); });
                    this.maxHandleElement.onPassive('touchstart', function (event) { return _this.onBarStart(PointerType.Max, draggableRange, event, true, true); });
                }
                else {
                    this.minHandleElement.onPassive('touchstart', function (event) { return _this.onStart(PointerType.Min, event, true, true); });
                    if (this.range) {
                        this.maxHandleElement.onPassive('touchstart', function (event) { return _this.onStart(PointerType.Max, event, true, true); });
                    }
                    if (!this.viewOptions.onlyBindHandles) {
                        this.fullBarElement.onPassive('touchstart', function (event) { return _this.onStart(null, event, true, true, true); });
                        this.ticksElement.onPassive('touchstart', function (event) { return _this.onStart(null, event, false, false, true, true); });
                    }
                }
                if (this.viewOptions.keyboardSupport) {
                    this.minHandleElement.on('focus', function () { return _this.onPointerFocus(PointerType.Min); });
                    if (this.range) {
                        this.maxHandleElement.on('focus', function () { return _this.onPointerFocus(PointerType.Max); });
                    }
                }
            };
        /**
         * @param {?} options
         * @return {?}
         */
        SliderComponent.prototype.getOptionsInfluencingEventBindings = /**
         * @param {?} options
         * @return {?}
         */
            function (options) {
                return [
                    options.disabled,
                    options.readOnly,
                    options.draggableRange,
                    options.draggableRangeOnly,
                    options.onlyBindHandles,
                    options.keyboardSupport
                ];
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.unbindEvents = /**
         * @return {?}
         */
            function () {
                this.unsubscribeOnMove();
                this.unsubscribeOnEnd();
                try {
                    for (var _a = __values(this.getAllSliderElements()), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var element = _b.value;
                        if (!ValueHelper.isNullOrUndefined(element)) {
                            element.off();
                        }
                    }
                }
                catch (e_3_1) {
                    e_3 = { error: e_3_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_3)
                            throw e_3.error;
                    }
                }
                var e_3, _c;
            };
        /**
         * @param {?} pointerType
         * @param {?} draggableRange
         * @param {?} event
         * @param {?} bindMove
         * @param {?} bindEnd
         * @param {?=} simulateImmediateMove
         * @param {?=} simulateImmediateEnd
         * @return {?}
         */
        SliderComponent.prototype.onBarStart = /**
         * @param {?} pointerType
         * @param {?} draggableRange
         * @param {?} event
         * @param {?} bindMove
         * @param {?} bindEnd
         * @param {?=} simulateImmediateMove
         * @param {?=} simulateImmediateEnd
         * @return {?}
         */
            function (pointerType, draggableRange, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {
                if (draggableRange) {
                    this.onDragStart(pointerType, event, bindMove, bindEnd);
                }
                else {
                    this.onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);
                }
            };
        /**
         * @param {?} pointerType
         * @param {?} event
         * @param {?} bindMove
         * @param {?} bindEnd
         * @param {?=} simulateImmediateMove
         * @param {?=} simulateImmediateEnd
         * @return {?}
         */
        SliderComponent.prototype.onStart = /**
         * @param {?} pointerType
         * @param {?} event
         * @param {?} bindMove
         * @param {?} bindEnd
         * @param {?=} simulateImmediateMove
         * @param {?=} simulateImmediateEnd
         * @return {?}
         */
            function (pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {
                var _this = this;
                event.stopPropagation();
                // Only call preventDefault() when handling non-passive events (passive events don't need it)
                if (!CompatibilityHelper.isTouchEvent(event) || !detectPassiveEvents.hasSupport) {
                    event.preventDefault();
                }
                this.moving = false;
                // We have to do this in case the HTML where the sliders are on
                // have been animated into view.
                this.calculateViewDimensions();
                if (ValueHelper.isNullOrUndefined(pointerType)) {
                    pointerType = this.getNearestHandle(event);
                }
                this.currentTrackingPointer = pointerType;
                /** @type {?} */
                var pointerElement = this.getPointerElement(pointerType);
                pointerElement.active = true;
                if (this.viewOptions.keyboardSupport) {
                    pointerElement.focus();
                }
                if (bindMove) {
                    this.unsubscribeOnMove();
                    /** @type {?} */
                    var onMoveCallback = function (e) { return _this.dragging.active ? _this.onDragMove(e) : _this.onMove(e); };
                    if (CompatibilityHelper.isTouchEvent(event)) {
                        this.onMoveEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchmove', onMoveCallback, this.viewOptions.touchEventsInterval);
                    }
                    else {
                        this.onMoveEventListener = this.eventListenerHelper.attachEventListener(document, 'mousemove', onMoveCallback, this.viewOptions.mouseEventsInterval);
                    }
                }
                if (bindEnd) {
                    this.unsubscribeOnEnd();
                    /** @type {?} */
                    var onEndCallback = function (e) { return _this.onEnd(e); };
                    if (CompatibilityHelper.isTouchEvent(event)) {
                        this.onEndEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchend', onEndCallback);
                    }
                    else {
                        this.onEndEventListener = this.eventListenerHelper.attachEventListener(document, 'mouseup', onEndCallback);
                    }
                }
                this.userChangeStart.emit(this.getChangeContext());
                if (CompatibilityHelper.isTouchEvent(event) && !ValueHelper.isNullOrUndefined(( /** @type {?} */(event)).changedTouches)) {
                    // Store the touch identifier
                    if (ValueHelper.isNullOrUndefined(this.touchId)) {
                        this.touchId = ( /** @type {?} */(event)).changedTouches[0].identifier;
                    }
                }
                // Click events, either with mouse or touch gesture are weird. Sometimes they result in full
                // start, move, end sequence, and sometimes, they don't - they only invoke mousedown
                // As a workaround, we simulate the first move event and the end event if it's necessary
                if (simulateImmediateMove) {
                    this.onMove(event, true);
                }
                if (simulateImmediateEnd) {
                    this.onEnd(event);
                }
            };
        /**
         * @param {?} event
         * @param {?=} fromTick
         * @return {?}
         */
        SliderComponent.prototype.onMove = /**
         * @param {?} event
         * @param {?=} fromTick
         * @return {?}
         */
            function (event, fromTick) {
                /** @type {?} */
                var touchForThisSlider = null;
                if (CompatibilityHelper.isTouchEvent(event)) {
                    /** @type {?} */
                    var changedTouches = ( /** @type {?} */(event)).changedTouches;
                    for (var i = 0; i < changedTouches.length; i++) {
                        if (changedTouches[i].identifier === this.touchId) {
                            touchForThisSlider = changedTouches[i];
                            break;
                        }
                    }
                    if (ValueHelper.isNullOrUndefined(touchForThisSlider)) {
                        return;
                    }
                }
                if (this.viewOptions.animate && !this.viewOptions.animateOnMove) {
                    if (this.moving) {
                        this.sliderElementAnimateClass = false;
                    }
                }
                this.moving = true;
                /** @type {?} */
                var newPos = !ValueHelper.isNullOrUndefined(touchForThisSlider)
                    ? this.getEventPosition(event, touchForThisSlider.identifier)
                    : this.getEventPosition(event);
                /** @type {?} */
                var newValue;
                /** @type {?} */
                var ceilValue = this.viewOptions.rightToLeft
                    ? this.viewOptions.floor
                    : this.viewOptions.ceil;
                /** @type {?} */
                var floorValue = this.viewOptions.rightToLeft ? this.viewOptions.ceil : this.viewOptions.floor;
                if (newPos <= 0) {
                    newValue = floorValue;
                }
                else if (newPos >= this.maxHandlePosition) {
                    newValue = ceilValue;
                }
                else {
                    newValue = this.positionToValue(newPos);
                    if (fromTick && !ValueHelper.isNullOrUndefined(this.viewOptions.tickStep)) {
                        newValue = this.roundStep(newValue, this.viewOptions.tickStep);
                    }
                    else {
                        newValue = this.roundStep(newValue);
                    }
                }
                this.positionTrackingHandle(newValue);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SliderComponent.prototype.onEnd = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (CompatibilityHelper.isTouchEvent(event)) {
                    /** @type {?} */
                    var changedTouches = ( /** @type {?} */(event)).changedTouches;
                    if (changedTouches[0].identifier !== this.touchId) {
                        return;
                    }
                }
                this.moving = false;
                if (this.viewOptions.animate) {
                    this.sliderElementAnimateClass = true;
                }
                this.touchId = null;
                if (!this.viewOptions.keyboardSupport) {
                    this.minHandleElement.active = false;
                    this.maxHandleElement.active = false;
                    this.currentTrackingPointer = null;
                }
                this.dragging.active = false;
                this.unsubscribeOnMove();
                this.unsubscribeOnEnd();
                this.userChangeEnd.emit(this.getChangeContext());
            };
        /**
         * @param {?} pointerType
         * @return {?}
         */
        SliderComponent.prototype.onPointerFocus = /**
         * @param {?} pointerType
         * @return {?}
         */
            function (pointerType) {
                var _this = this;
                /** @type {?} */
                var pointerElement = this.getPointerElement(pointerType);
                pointerElement.on('blur', function () { return _this.onPointerBlur(pointerElement); });
                pointerElement.on('keydown', function (event) { return _this.onKeyboardEvent(event); });
                pointerElement.on('keyup', function () { return _this.onKeyUp(); });
                pointerElement.active = true;
                this.currentTrackingPointer = pointerType;
                this.currentFocusPointer = pointerType;
                this.firstKeyDown = true;
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.onKeyUp = /**
         * @return {?}
         */
            function () {
                this.firstKeyDown = true;
                this.userChangeEnd.emit(this.getChangeContext());
            };
        /**
         * @param {?} pointer
         * @return {?}
         */
        SliderComponent.prototype.onPointerBlur = /**
         * @param {?} pointer
         * @return {?}
         */
            function (pointer) {
                pointer.off('blur');
                pointer.off('keydown');
                pointer.off('keyup');
                pointer.active = false;
                if (ValueHelper.isNullOrUndefined(this.touchId)) {
                    this.currentTrackingPointer = null;
                    this.currentFocusPointer = null;
                }
            };
        /**
         * @param {?} currentValue
         * @return {?}
         */
        SliderComponent.prototype.getKeyActions = /**
         * @param {?} currentValue
         * @return {?}
         */
            function (currentValue) {
                /** @type {?} */
                var valueRange = this.viewOptions.ceil - this.viewOptions.floor;
                /** @type {?} */
                var increaseStep = currentValue + this.viewOptions.step;
                /** @type {?} */
                var decreaseStep = currentValue - this.viewOptions.step;
                /** @type {?} */
                var increasePage = currentValue + valueRange / 10;
                /** @type {?} */
                var decreasePage = currentValue - valueRange / 10;
                if (this.viewOptions.reversedControls) {
                    increaseStep = currentValue - this.viewOptions.step;
                    decreaseStep = currentValue + this.viewOptions.step;
                    increasePage = currentValue - valueRange / 10;
                    decreasePage = currentValue + valueRange / 10;
                }
                /** @type {?} */
                var actions = {
                    UP: increaseStep,
                    DOWN: decreaseStep,
                    LEFT: decreaseStep,
                    RIGHT: increaseStep,
                    PAGEUP: increasePage,
                    PAGEDOWN: decreasePage,
                    HOME: this.viewOptions.reversedControls ? this.viewOptions.ceil : this.viewOptions.floor,
                    END: this.viewOptions.reversedControls ? this.viewOptions.floor : this.viewOptions.ceil,
                };
                // right to left means swapping right and left arrows
                if (this.viewOptions.rightToLeft) {
                    actions["LEFT"] = increaseStep;
                    actions["RIGHT"] = decreaseStep;
                    // right to left and vertical means we also swap up and down
                    if (this.viewOptions.vertical) {
                        actions["UP"] = decreaseStep;
                        actions["DOWN"] = increaseStep;
                    }
                }
                return actions;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SliderComponent.prototype.onKeyboardEvent = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var currentValue = this.getCurrentTrackingValue();
                /** @type {?} */
                var keyCode = !ValueHelper.isNullOrUndefined(event.keyCode)
                    ? event.keyCode
                    : event.which;
                /** @type {?} */
                var keys = {
                    38: 'UP',
                    40: 'DOWN',
                    37: 'LEFT',
                    39: 'RIGHT',
                    33: 'PAGEUP',
                    34: 'PAGEDOWN',
                    36: 'HOME',
                    35: 'END',
                };
                /** @type {?} */
                var actions = this.getKeyActions(currentValue);
                /** @type {?} */
                var key = keys[keyCode];
                /** @type {?} */
                var action = actions[key];
                if (ValueHelper.isNullOrUndefined(action) || ValueHelper.isNullOrUndefined(this.currentTrackingPointer)) {
                    return;
                }
                event.preventDefault();
                if (this.firstKeyDown) {
                    this.firstKeyDown = false;
                    this.userChangeStart.emit(this.getChangeContext());
                }
                /** @type {?} */
                var actionValue = MathHelper.clampToRange(action, this.viewOptions.floor, this.viewOptions.ceil);
                /** @type {?} */
                var newValue = this.roundStep(actionValue);
                if (!this.viewOptions.draggableRangeOnly) {
                    this.positionTrackingHandle(newValue);
                }
                else {
                    /** @type {?} */
                    var difference = this.viewHighValue - this.viewLowValue;
                    /** @type {?} */
                    var newMinValue = void 0;
                    /** @type {?} */
                    var newMaxValue = void 0;
                    if (this.currentTrackingPointer === PointerType.Min) {
                        newMinValue = newValue;
                        newMaxValue = newValue + difference;
                        if (newMaxValue > this.viewOptions.ceil) {
                            newMaxValue = this.viewOptions.ceil;
                            newMinValue = newMaxValue - difference;
                        }
                    }
                    else if (this.currentTrackingPointer === PointerType.Max) {
                        newMaxValue = newValue;
                        newMinValue = newValue - difference;
                        if (newMinValue < this.viewOptions.floor) {
                            newMinValue = this.viewOptions.floor;
                            newMaxValue = newMinValue + difference;
                        }
                    }
                    this.positionTrackingBar(newMinValue, newMaxValue);
                }
            };
        /**
         * @param {?} pointerType
         * @param {?} event
         * @param {?} bindMove
         * @param {?} bindEnd
         * @return {?}
         */
        SliderComponent.prototype.onDragStart = /**
         * @param {?} pointerType
         * @param {?} event
         * @param {?} bindMove
         * @param {?} bindEnd
         * @return {?}
         */
            function (pointerType, event, bindMove, bindEnd) {
                /** @type {?} */
                var position = this.getEventPosition(event);
                this.dragging = new Dragging();
                this.dragging.active = true;
                this.dragging.value = this.positionToValue(position);
                this.dragging.difference = this.viewHighValue - this.viewLowValue;
                this.dragging.lowLimit = this.viewOptions.rightToLeft
                    ? this.minHandleElement.position - position
                    : position - this.minHandleElement.position;
                this.dragging.highLimit = this.viewOptions.rightToLeft
                    ? position - this.maxHandleElement.position
                    : this.maxHandleElement.position - position;
                this.onStart(pointerType, event, bindMove, bindEnd);
            };
        /**
         * Get min value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft
         * @param {?} newPos
         * @param {?} outOfBounds
         * @param {?} isAbove
         * @return {?}
         */
        SliderComponent.prototype.getMinValue = /**
         * Get min value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft
         * @param {?} newPos
         * @param {?} outOfBounds
         * @param {?} isAbove
         * @return {?}
         */
            function (newPos, outOfBounds, isAbove) {
                /** @type {?} */
                var isRTL = this.viewOptions.rightToLeft;
                /** @type {?} */
                var value = null;
                if (outOfBounds) {
                    if (isAbove) {
                        value = isRTL
                            ? this.viewOptions.floor
                            : this.viewOptions.ceil - this.dragging.difference;
                    }
                    else {
                        value = isRTL
                            ? this.viewOptions.ceil - this.dragging.difference
                            : this.viewOptions.floor;
                    }
                }
                else {
                    value = isRTL
                        ? this.positionToValue(newPos + this.dragging.lowLimit)
                        : this.positionToValue(newPos - this.dragging.lowLimit);
                }
                return this.roundStep(value);
            };
        /**
         * Get max value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft
         * @param {?} newPos
         * @param {?} outOfBounds
         * @param {?} isAbove
         * @return {?}
         */
        SliderComponent.prototype.getMaxValue = /**
         * Get max value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft
         * @param {?} newPos
         * @param {?} outOfBounds
         * @param {?} isAbove
         * @return {?}
         */
            function (newPos, outOfBounds, isAbove) {
                /** @type {?} */
                var isRTL = this.viewOptions.rightToLeft;
                /** @type {?} */
                var value = null;
                if (outOfBounds) {
                    if (isAbove) {
                        value = isRTL
                            ? this.viewOptions.floor + this.dragging.difference
                            : this.viewOptions.ceil;
                    }
                    else {
                        value = isRTL
                            ? this.viewOptions.ceil
                            : this.viewOptions.floor + this.dragging.difference;
                    }
                }
                else {
                    if (isRTL) {
                        value =
                            this.positionToValue(newPos + this.dragging.lowLimit) +
                                this.dragging.difference;
                    }
                    else {
                        value =
                            this.positionToValue(newPos - this.dragging.lowLimit) +
                                this.dragging.difference;
                    }
                }
                return this.roundStep(value);
            };
        /**
         * @param {?=} event
         * @return {?}
         */
        SliderComponent.prototype.onDragMove = /**
         * @param {?=} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var newPos = this.getEventPosition(event);
                if (this.viewOptions.animate && !this.viewOptions.animateOnMove) {
                    if (this.moving) {
                        this.sliderElementAnimateClass = false;
                    }
                }
                this.moving = true;
                /** @type {?} */
                var ceilLimit;
                /** @type {?} */
                var floorLimit;
                /** @type {?} */
                var floorHandleElement;
                /** @type {?} */
                var ceilHandleElement;
                if (this.viewOptions.rightToLeft) {
                    ceilLimit = this.dragging.lowLimit;
                    floorLimit = this.dragging.highLimit;
                    floorHandleElement = this.maxHandleElement;
                    ceilHandleElement = this.minHandleElement;
                }
                else {
                    ceilLimit = this.dragging.highLimit;
                    floorLimit = this.dragging.lowLimit;
                    floorHandleElement = this.minHandleElement;
                    ceilHandleElement = this.maxHandleElement;
                }
                /** @type {?} */
                var isUnderFloorLimit = (newPos <= floorLimit);
                /** @type {?} */
                var isOverCeilLimit = (newPos >= this.maxHandlePosition - ceilLimit);
                /** @type {?} */
                var newMinValue;
                /** @type {?} */
                var newMaxValue;
                if (isUnderFloorLimit) {
                    if (floorHandleElement.position === 0) {
                        return;
                    }
                    newMinValue = this.getMinValue(newPos, true, false);
                    newMaxValue = this.getMaxValue(newPos, true, false);
                }
                else if (isOverCeilLimit) {
                    if (ceilHandleElement.position === this.maxHandlePosition) {
                        return;
                    }
                    newMaxValue = this.getMaxValue(newPos, true, true);
                    newMinValue = this.getMinValue(newPos, true, true);
                }
                else {
                    newMinValue = this.getMinValue(newPos, false, false);
                    newMaxValue = this.getMaxValue(newPos, false, false);
                }
                this.positionTrackingBar(newMinValue, newMaxValue);
            };
        /**
         * @param {?} newMinValue
         * @param {?} newMaxValue
         * @return {?}
         */
        SliderComponent.prototype.positionTrackingBar = /**
         * @param {?} newMinValue
         * @param {?} newMaxValue
         * @return {?}
         */
            function (newMinValue, newMaxValue) {
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) &&
                    newMinValue < this.viewOptions.minLimit) {
                    newMinValue = this.viewOptions.minLimit;
                    newMaxValue = MathHelper.roundToPrecisionLimit(newMinValue + this.dragging.difference, this.viewOptions.precisionLimit);
                }
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) &&
                    newMaxValue > this.viewOptions.maxLimit) {
                    newMaxValue = this.viewOptions.maxLimit;
                    newMinValue = MathHelper.roundToPrecisionLimit(newMaxValue - this.dragging.difference, this.viewOptions.precisionLimit);
                }
                this.viewLowValue = newMinValue;
                this.viewHighValue = newMaxValue;
                this.applyViewChange();
                this.updateHandles(PointerType.Min, this.valueToPosition(newMinValue));
                this.updateHandles(PointerType.Max, this.valueToPosition(newMaxValue));
            };
        /**
         * @param {?} newValue
         * @return {?}
         */
        SliderComponent.prototype.positionTrackingHandle = /**
         * @param {?} newValue
         * @return {?}
         */
            function (newValue) {
                newValue = this.applyMinMaxLimit(newValue);
                if (this.range) {
                    if (this.viewOptions.pushRange) {
                        newValue = this.applyPushRange(newValue);
                    }
                    else {
                        if (this.viewOptions.noSwitching) {
                            if (this.currentTrackingPointer === PointerType.Min &&
                                newValue > this.viewHighValue) {
                                newValue = this.applyMinMaxRange(this.viewHighValue);
                            }
                            else if (this.currentTrackingPointer === PointerType.Max &&
                                newValue < this.viewLowValue) {
                                newValue = this.applyMinMaxRange(this.viewLowValue);
                            }
                        }
                        newValue = this.applyMinMaxRange(newValue);
                        /* This is to check if we need to switch the min and max handles */
                        if (this.currentTrackingPointer === PointerType.Min && newValue > this.viewHighValue) {
                            this.viewLowValue = this.viewHighValue;
                            this.applyViewChange();
                            this.updateHandles(PointerType.Min, this.maxHandleElement.position);
                            this.updateAriaAttributes();
                            this.currentTrackingPointer = PointerType.Max;
                            this.minHandleElement.active = false;
                            this.maxHandleElement.active = true;
                            if (this.viewOptions.keyboardSupport) {
                                this.maxHandleElement.focus();
                            }
                        }
                        else if (this.currentTrackingPointer === PointerType.Max &&
                            newValue < this.viewLowValue) {
                            this.viewHighValue = this.viewLowValue;
                            this.applyViewChange();
                            this.updateHandles(PointerType.Max, this.minHandleElement.position);
                            this.updateAriaAttributes();
                            this.currentTrackingPointer = PointerType.Min;
                            this.maxHandleElement.active = false;
                            this.minHandleElement.active = true;
                            if (this.viewOptions.keyboardSupport) {
                                this.minHandleElement.focus();
                            }
                        }
                    }
                }
                if (this.getCurrentTrackingValue() !== newValue) {
                    if (this.currentTrackingPointer === PointerType.Min) {
                        this.viewLowValue = newValue;
                        this.applyViewChange();
                    }
                    else if (this.currentTrackingPointer === PointerType.Max) {
                        this.viewHighValue = newValue;
                        this.applyViewChange();
                    }
                    this.updateHandles(this.currentTrackingPointer, this.valueToPosition(newValue));
                    this.updateAriaAttributes();
                }
            };
        /**
         * @param {?} newValue
         * @return {?}
         */
        SliderComponent.prototype.applyMinMaxLimit = /**
         * @param {?} newValue
         * @return {?}
         */
            function (newValue) {
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) && newValue < this.viewOptions.minLimit) {
                    return this.viewOptions.minLimit;
                }
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) && newValue > this.viewOptions.maxLimit) {
                    return this.viewOptions.maxLimit;
                }
                return newValue;
            };
        /**
         * @param {?} newValue
         * @return {?}
         */
        SliderComponent.prototype.applyMinMaxRange = /**
         * @param {?} newValue
         * @return {?}
         */
            function (newValue) {
                /** @type {?} */
                var oppositeValue = (this.currentTrackingPointer === PointerType.Min)
                    ? this.viewHighValue
                    : this.viewLowValue;
                /** @type {?} */
                var difference = Math.abs(newValue - oppositeValue);
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.minRange)) {
                    if (difference < this.viewOptions.minRange) {
                        if (this.currentTrackingPointer === PointerType.Min) {
                            return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.minRange, this.viewOptions.precisionLimit);
                        }
                        else if (this.currentTrackingPointer === PointerType.Max) {
                            return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.minRange, this.viewOptions.precisionLimit);
                        }
                    }
                }
                if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxRange)) {
                    if (difference > this.viewOptions.maxRange) {
                        if (this.currentTrackingPointer === PointerType.Min) {
                            return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.maxRange, this.viewOptions.precisionLimit);
                        }
                        else if (this.currentTrackingPointer === PointerType.Max) {
                            return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.maxRange, this.viewOptions.precisionLimit);
                        }
                    }
                }
                return newValue;
            };
        /**
         * @param {?} newValue
         * @return {?}
         */
        SliderComponent.prototype.applyPushRange = /**
         * @param {?} newValue
         * @return {?}
         */
            function (newValue) {
                /** @type {?} */
                var difference = (this.currentTrackingPointer === PointerType.Min)
                    ? this.viewHighValue - newValue
                    : newValue - this.viewLowValue;
                /** @type {?} */
                var minRange = (!ValueHelper.isNullOrUndefined(this.viewOptions.minRange))
                    ? this.viewOptions.minRange
                    : this.viewOptions.step;
                /** @type {?} */
                var maxRange = this.viewOptions.maxRange;
                // if smaller than minRange
                if (difference < minRange) {
                    if (this.currentTrackingPointer === PointerType.Min) {
                        this.viewHighValue = MathHelper.roundToPrecisionLimit(Math.min(newValue + minRange, this.viewOptions.ceil), this.viewOptions.precisionLimit);
                        newValue = MathHelper.roundToPrecisionLimit(this.viewHighValue - minRange, this.viewOptions.precisionLimit);
                        this.applyViewChange();
                        this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));
                    }
                    else if (this.currentTrackingPointer === PointerType.Max) {
                        this.viewLowValue = MathHelper.roundToPrecisionLimit(Math.max(newValue - minRange, this.viewOptions.floor), this.viewOptions.precisionLimit);
                        newValue = MathHelper.roundToPrecisionLimit(this.viewLowValue + minRange, this.viewOptions.precisionLimit);
                        this.applyViewChange();
                        this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));
                    }
                    this.updateAriaAttributes();
                }
                else if (!ValueHelper.isNullOrUndefined(maxRange) && difference > maxRange) {
                    // if greater than maxRange
                    if (this.currentTrackingPointer === PointerType.Min) {
                        this.viewHighValue = MathHelper.roundToPrecisionLimit(newValue + maxRange, this.viewOptions.precisionLimit);
                        this.applyViewChange();
                        this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));
                    }
                    else if (this.currentTrackingPointer === PointerType.Max) {
                        this.viewLowValue = MathHelper.roundToPrecisionLimit(newValue - maxRange, this.viewOptions.precisionLimit);
                        this.applyViewChange();
                        this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));
                    }
                    this.updateAriaAttributes();
                }
                return newValue;
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.getChangeContext = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var changeContext = new ChangeContext();
                changeContext.pointerType = this.currentTrackingPointer;
                changeContext.value = +this.value;
                if (this.range) {
                    changeContext.highValue = +this.highValue;
                }
                return changeContext;
            };
        /** @nocollapse */
        SliderComponent.ctorParameters = function () {
            return [
                { type: core.Renderer2 },
                { type: core.ElementRef },
                { type: core.ChangeDetectorRef },
                { type: core.NgZone }
            ];
        };
        SliderComponent.propDecorators = {
            value: [{ type: core.Input }],
            valueChange: [{ type: core.Output }],
            highValue: [{ type: core.Input }],
            highValueChange: [{ type: core.Output }],
            options: [{ type: core.Input }],
            userChangeStart: [{ type: core.Output }],
            userChange: [{ type: core.Output }],
            userChangeEnd: [{ type: core.Output }],
            manualRefresh: [{ type: core.Input }],
            triggerFocus: [{ type: core.Input }],
            leftOuterSelectionBarElement: [{ type: core.ViewChild, args: ['leftOuterSelectionBar', { read: SliderElementDirective },] }],
            rightOuterSelectionBarElement: [{ type: core.ViewChild, args: ['rightOuterSelectionBar', { read: SliderElementDirective },] }],
            fullBarElement: [{ type: core.ViewChild, args: ['fullBar', { read: SliderElementDirective },] }],
            selectionBarElement: [{ type: core.ViewChild, args: ['selectionBar', { read: SliderElementDirective },] }],
            minHandleElement: [{ type: core.ViewChild, args: ['minHandle', { read: SliderHandleDirective },] }],
            maxHandleElement: [{ type: core.ViewChild, args: ['maxHandle', { read: SliderHandleDirective },] }],
            floorLabelElement: [{ type: core.ViewChild, args: ['floorLabel', { read: SliderLabelDirective },] }],
            ceilLabelElement: [{ type: core.ViewChild, args: ['ceilLabel', { read: SliderLabelDirective },] }],
            minHandleLabelElement: [{ type: core.ViewChild, args: ['minHandleLabel', { read: SliderLabelDirective },] }],
            maxHandleLabelElement: [{ type: core.ViewChild, args: ['maxHandleLabel', { read: SliderLabelDirective },] }],
            combinedLabelElement: [{ type: core.ViewChild, args: ['combinedLabel', { read: SliderLabelDirective },] }],
            ticksElement: [{ type: core.ViewChild, args: ['ticksElement', { read: SliderElementDirective },] }],
            tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }],
            sliderElementVerticalClass: [{ type: core.HostBinding, args: ['class.vertical',] }],
            sliderElementAnimateClass: [{ type: core.HostBinding, args: ['class.animate',] }],
            sliderElementWithLegendClass: [{ type: core.HostBinding, args: ['class.with-legend',] }],
            sliderElementDisabledAttr: [{ type: core.HostBinding, args: ['attr.disabled',] }],
            onResize: [{ type: core.HostListener, args: ['window:resize', ['$event'],] }]
        };
SliderComponent.ɵfac = function SliderComponent_Factory(t) { return new (t || SliderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
SliderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SliderComponent, selectors: [["ngx-slider"]], contentQueries: function SliderComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, viewQuery: function SliderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c1, true, SliderElementDirective);
        ɵngcc0.ɵɵviewQuery(_c2, true, SliderElementDirective);
        ɵngcc0.ɵɵviewQuery(_c3, true, SliderElementDirective);
        ɵngcc0.ɵɵviewQuery(_c4, true, SliderElementDirective);
        ɵngcc0.ɵɵviewQuery(_c5, true, SliderHandleDirective);
        ɵngcc0.ɵɵviewQuery(_c6, true, SliderHandleDirective);
        ɵngcc0.ɵɵviewQuery(_c7, true, SliderLabelDirective);
        ɵngcc0.ɵɵviewQuery(_c8, true, SliderLabelDirective);
        ɵngcc0.ɵɵviewQuery(_c9, true, SliderLabelDirective);
        ɵngcc0.ɵɵviewQuery(_c10, true, SliderLabelDirective);
        ɵngcc0.ɵɵviewQuery(_c11, true, SliderLabelDirective);
        ɵngcc0.ɵɵviewQuery(_c12, true, SliderElementDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.leftOuterSelectionBarElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rightOuterSelectionBarElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fullBarElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.selectionBarElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.minHandleElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.maxHandleElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.floorLabelElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ceilLabelElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.minHandleLabelElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.maxHandleLabelElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.combinedLabelElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);
    } }, hostAttrs: [1, "ngx-slider"], hostVars: 7, hostBindings: function SliderComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("resize", function SliderComponent_resize_HostBindingHandler($event) { return ctx.onResize($event); }, false, ɵngcc0.ɵɵresolveWindow);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("disabled", ctx.sliderElementDisabledAttr);
        ɵngcc0.ɵɵclassProp("vertical", ctx.sliderElementVerticalClass)("animate", ctx.sliderElementAnimateClass)("with-legend", ctx.sliderElementWithLegendClass);
    } }, inputs: { value: "value", highValue: "highValue", options: "options", manualRefresh: "manualRefresh", triggerFocus: "triggerFocus" }, outputs: { valueChange: "valueChange", highValueChange: "highValueChange", userChangeStart: "userChangeStart", userChange: "userChange", userChangeEnd: "userChangeEnd" }, features: [ɵngcc0.ɵɵProvidersFeature([NGX_SLIDER_CONTROL_VALUE_ACCESSOR]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 29, vars: 13, consts: [["ngxSliderElement", "", 1, "ngx-slider-span", "ngx-slider-bar-wrapper", "ngx-slider-left-out-selection"], ["leftOuterSelectionBar", ""], [1, "ngx-slider-span", "ngx-slider-bar"], ["ngxSliderElement", "", 1, "ngx-slider-span", "ngx-slider-bar-wrapper", "ngx-slider-right-out-selection"], ["rightOuterSelectionBar", ""], ["ngxSliderElement", "", 1, "ngx-slider-span", "ngx-slider-bar-wrapper", "ngx-slider-full-bar"], ["fullBar", ""], ["ngxSliderElement", "", 1, "ngx-slider-span", "ngx-slider-bar-wrapper", "ngx-slider-selection-bar"], ["selectionBar", ""], [1, "ngx-slider-span", "ngx-slider-bar", "ngx-slider-selection", 3, "ngStyle"], ["ngxSliderHandle", "", 1, "ngx-slider-span", "ngx-slider-pointer", "ngx-slider-pointer-min", 3, "ngStyle"], ["minHandle", ""], ["ngxSliderHandle", "", 1, "ngx-slider-span", "ngx-slider-pointer", "ngx-slider-pointer-max", 3, "ngStyle"], ["maxHandle", ""], ["ngxSliderLabel", "", 1, "ngx-slider-span", "ngx-slider-bubble", "ngx-slider-limit", "ngx-slider-floor"], ["floorLabel", ""], ["ngxSliderLabel", "", 1, "ngx-slider-span", "ngx-slider-bubble", "ngx-slider-limit", "ngx-slider-ceil"], ["ceilLabel", ""], ["ngxSliderLabel", "", 1, "ngx-slider-span", "ngx-slider-bubble", "ngx-slider-model-value"], ["minHandleLabel", ""], ["ngxSliderLabel", "", 1, "ngx-slider-span", "ngx-slider-bubble", "ngx-slider-model-high"], ["maxHandleLabel", ""], ["ngxSliderLabel", "", 1, "ngx-slider-span", "ngx-slider-bubble", "ngx-slider-combined"], ["combinedLabel", ""], ["ngxSliderElement", "", 1, "ngx-slider-ticks", 3, "hidden"], ["ticksElement", ""], ["class", "ngx-slider-tick", 3, "ngClass", "ngStyle", 4, "ngFor", "ngForOf"], [1, "ngx-slider-tick", 3, "ngClass", "ngStyle"], [3, "template", "tooltip", "placement"], ["class", "ngx-slider-span ngx-slider-tick-value", 3, "template", "tooltip", "placement", "content", 4, "ngIf"], ["class", "ngx-slider-span ngx-slider-tick-legend", 3, "innerHTML", 4, "ngIf"], [1, "ngx-slider-span", "ngx-slider-tick-value", 3, "template", "tooltip", "placement", "content"], [1, "ngx-slider-span", "ngx-slider-tick-legend", 3, "innerHTML"]], template: function SliderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0, 1);
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "span", 3, 4);
        ɵngcc0.ɵɵelement(5, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "span", 5, 6);
        ɵngcc0.ɵɵelement(8, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "span", 7, 8);
        ɵngcc0.ɵɵelement(11, "span", 9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(12, "span", 10, 11);
        ɵngcc0.ɵɵelement(14, "span", 12, 13);
        ɵngcc0.ɵɵelement(16, "span", 14, 15);
        ɵngcc0.ɵɵelement(18, "span", 16, 17);
        ɵngcc0.ɵɵelement(20, "span", 18, 19);
        ɵngcc0.ɵɵelement(22, "span", 20, 21);
        ɵngcc0.ɵɵelement(24, "span", 22, 23);
        ɵngcc0.ɵɵelementStart(26, "span", 24, 25);
        ɵngcc0.ɵɵtemplate(28, SliderComponent_span_28_Template, 4, 9, "span", 26);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵclassProp("ngx-slider-transparent", ctx.fullBarTransparentClass);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵclassProp("ngx-slider-draggable", ctx.selectionBarDraggableClass);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.barStyle);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.minPointerStyle);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("display", ctx.range ? "inherit" : "none");
        ɵngcc0.ɵɵproperty("ngStyle", ctx.maxPointerStyle);
        ɵngcc0.ɵɵadvance(12);
        ɵngcc0.ɵɵclassProp("ngx-slider-ticks-values-under", ctx.ticksUnderValuesClass);
        ɵngcc0.ɵɵproperty("hidden", !ctx.showTicks);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
    } }, directives: function () { return [SliderElementDirective, ɵngcc1.NgStyle, SliderHandleDirective, SliderLabelDirective, ɵngcc1.NgForOf, ɵngcc1.NgClass, TooltipWrapperComponent, ɵngcc1.NgIf]; }, styles: [".ngx-slider{display:inline-block;position:relative;height:4px;width:100%;margin:35px 0 15px;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;touch-action:pan-y}  .ngx-slider.with-legend{margin-bottom:40px}  .ngx-slider[disabled]{cursor:not-allowed}  .ngx-slider[disabled] .ngx-slider-pointer{cursor:not-allowed;background-color:#d8e0f3}  .ngx-slider[disabled] .ngx-slider-draggable{cursor:not-allowed}  .ngx-slider[disabled] .ngx-slider-selection{background:#8b91a2}  .ngx-slider[disabled] .ngx-slider-tick{cursor:not-allowed}  .ngx-slider[disabled] .ngx-slider-tick.ngx-slider-selected{background:#8b91a2}  .ngx-slider .ngx-slider-span{white-space:nowrap;position:absolute;display:inline-block}  .ngx-slider .ngx-slider-base{width:100%;height:100%;padding:0}  .ngx-slider .ngx-slider-bar-wrapper{left:0;box-sizing:border-box;margin-top:-16px;padding-top:16px;width:100%;height:32px;z-index:1}  .ngx-slider .ngx-slider-draggable{cursor:move}  .ngx-slider .ngx-slider-bar{left:0;width:100%;height:4px;z-index:1;background:#d8e0f3;border-radius:2px}  .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-transparent .ngx-slider-bar{background:0 0}  .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-left-out-selection .ngx-slider-bar{background:#df002d}  .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-right-out-selection .ngx-slider-bar{background:#03a688}  .ngx-slider .ngx-slider-selection{z-index:2;background:#0db9f0;border-radius:2px}  .ngx-slider .ngx-slider-pointer{cursor:pointer;width:32px;height:32px;top:-14px;background-color:#0db9f0;z-index:3;border-radius:16px}  .ngx-slider .ngx-slider-pointer:after{content:'';width:8px;height:8px;position:absolute;top:12px;left:12px;border-radius:4px;background:#fff}  .ngx-slider .ngx-slider-pointer:hover:after{background-color:#fff}  .ngx-slider .ngx-slider-pointer.ngx-slider-active{z-index:4}  .ngx-slider .ngx-slider-pointer.ngx-slider-active:after{background-color:#451aff}  .ngx-slider .ngx-slider-bubble{cursor:default;bottom:16px;padding:1px 3px;color:#55637d;font-size:16px}  .ngx-slider .ngx-slider-bubble.ngx-slider-limit{color:#55637d}  .ngx-slider .ngx-slider-ticks{box-sizing:border-box;width:100%;height:0;position:absolute;left:0;top:-3px;margin:0;z-index:1;list-style:none}  .ngx-slider .ngx-slider-ticks-values-under .ngx-slider-tick-value{top:auto;bottom:-36px}  .ngx-slider .ngx-slider-tick{text-align:center;cursor:pointer;width:10px;height:10px;background:#d8e0f3;border-radius:50%;position:absolute;top:0;left:0;margin-left:11px}  .ngx-slider .ngx-slider-tick.ngx-slider-selected{background:#0db9f0}  .ngx-slider .ngx-slider-tick-value{position:absolute;top:-34px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0)}  .ngx-slider .ngx-slider-tick-legend{position:absolute;top:24px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);max-width:50px;white-space:normal}  .ngx-slider.vertical{position:relative;width:4px;height:100%;margin:0 20px;padding:0;vertical-align:baseline;touch-action:pan-x}  .ngx-slider.vertical .ngx-slider-base{width:100%;height:100%;padding:0}  .ngx-slider.vertical .ngx-slider-bar-wrapper{top:auto;left:0;margin:0 0 0 -16px;padding:0 0 0 16px;height:100%;width:32px}  .ngx-slider.vertical .ngx-slider-bar{bottom:0;left:auto;width:4px;height:100%}  .ngx-slider.vertical .ngx-slider-pointer{left:-14px!important;top:auto;bottom:0}  .ngx-slider.vertical .ngx-slider-bubble{left:16px!important;bottom:0}  .ngx-slider.vertical .ngx-slider-ticks{height:100%;width:0;left:-3px;top:0;z-index:1}  .ngx-slider.vertical .ngx-slider-tick{vertical-align:middle;margin-left:auto;margin-top:11px}  .ngx-slider.vertical .ngx-slider-tick-value{left:24px;top:auto;-webkit-transform:translate(0,-28%);transform:translate(0,-28%)}  .ngx-slider.vertical .ngx-slider-tick-legend{top:auto;right:24px;-webkit-transform:translate(0,-28%);transform:translate(0,-28%);max-width:none;white-space:nowrap}  .ngx-slider.vertical .ngx-slider-ticks-values-under .ngx-slider-tick-value{bottom:auto;left:auto;right:24px}  .ngx-slider *{transition:none}  .ngx-slider.animate .ngx-slider-bar-wrapper{transition:.3s linear}  .ngx-slider.animate .ngx-slider-selection{transition:background-color .3s linear}  .ngx-slider.animate .ngx-slider-pointer{transition:.3s linear}  .ngx-slider.animate .ngx-slider-bubble{transition:.3s linear}  .ngx-slider.animate .ngx-slider-bubble.ngx-slider-limit{transition:opacity .3s linear}  .ngx-slider.animate .ngx-slider-bubble.ngx-slider-combined{transition:opacity .3s linear}  .ngx-slider.animate .ngx-slider-tick{transition:background-color .3s linear}"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SliderComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-slider',
                template: "<!-- // 0 Left selection bar outside two handles -->\n<span ngxSliderElement #leftOuterSelectionBar class=\"ngx-slider-span ngx-slider-bar-wrapper ngx-slider-left-out-selection\">\n  <span class=\"ngx-slider-span ngx-slider-bar\"></span>\n</span>\n<!-- // 1 Right selection bar outside two handles -->\n<span ngxSliderElement #rightOuterSelectionBar class=\"ngx-slider-span ngx-slider-bar-wrapper ngx-slider-right-out-selection\">\n  <span class=\"ngx-slider-span ngx-slider-bar\"></span>\n</span>\n<!-- // 2 The whole slider bar -->\n<span ngxSliderElement #fullBar [class.ngx-slider-transparent]=\"fullBarTransparentClass\" class=\"ngx-slider-span ngx-slider-bar-wrapper ngx-slider-full-bar\">\n  <span class=\"ngx-slider-span ngx-slider-bar\"></span>\n</span>\n<!-- // 3 Selection bar between two handles -->\n<span ngxSliderElement #selectionBar [class.ngx-slider-draggable]=\"selectionBarDraggableClass\" class=\"ngx-slider-span ngx-slider-bar-wrapper ngx-slider-selection-bar\">\n  <span class=\"ngx-slider-span ngx-slider-bar ngx-slider-selection\" [ngStyle]=\"barStyle\"></span>\n</span>\n<!-- // 4 Low slider handle -->\n<span ngxSliderHandle #minHandle class=\"ngx-slider-span ngx-slider-pointer ngx-slider-pointer-min\" [ngStyle]=minPointerStyle></span>\n<!-- // 5 High slider handle -->\n<span ngxSliderHandle #maxHandle [style.display]=\"range ? 'inherit' : 'none'\" class=\"ngx-slider-span ngx-slider-pointer ngx-slider-pointer-max\" [ngStyle]=maxPointerStyle></span>\n<!-- // 6 Floor label -->\n<span ngxSliderLabel #floorLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-limit ngx-slider-floor\"></span>\n<!-- // 7 Ceiling label -->\n<span ngxSliderLabel #ceilLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-limit ngx-slider-ceil\"></span>\n<!-- // 8 Label above the low slider handle -->\n<span ngxSliderLabel #minHandleLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-model-value\"></span>\n<!-- // 9 Label above the high slider handle -->\n<span ngxSliderLabel #maxHandleLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-model-high\"></span>\n<!-- // 10 Combined range label when the slider handles are close ex. 15 - 17 -->\n<span ngxSliderLabel #combinedLabel class=\"ngx-slider-span ngx-slider-bubble ngx-slider-combined\"></span>\n<!-- // 11 The ticks -->\n<span ngxSliderElement #ticksElement [hidden]=\"!showTicks\" [class.ngx-slider-ticks-values-under]=\"ticksUnderValuesClass\" class=\"ngx-slider-ticks\">\n  <span *ngFor=\"let t of ticks\" class=\"ngx-slider-tick\" [ngClass]=\"{'ngx-slider-selected': t.selected}\" [ngStyle]=\"t.style\">\n    <ngx-slider-tooltip-wrapper [template]=\"tooltipTemplate\" [tooltip]=\"t.tooltip\" [placement]=\"t.tooltipPlacement\"></ngx-slider-tooltip-wrapper>\n    <ngx-slider-tooltip-wrapper *ngIf=\"t.value != null\" class=\"ngx-slider-span ngx-slider-tick-value\"\n        [template]=\"tooltipTemplate\" [tooltip]=\"t.valueTooltip\" [placement]=\"t.valueTooltipPlacement\" [content]=\"t.value\"></ngx-slider-tooltip-wrapper>\n    <span *ngIf=\"t.legend != null\" class=\"ngx-slider-span ngx-slider-tick-legend\" [innerHTML]=\"t.legend\"></span>\n  </span>\n</span>",
                styles: ["::ng-deep .ngx-slider{display:inline-block;position:relative;height:4px;width:100%;margin:35px 0 15px;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;touch-action:pan-y}::ng-deep .ngx-slider.with-legend{margin-bottom:40px}::ng-deep .ngx-slider[disabled]{cursor:not-allowed}::ng-deep .ngx-slider[disabled] .ngx-slider-pointer{cursor:not-allowed;background-color:#d8e0f3}::ng-deep .ngx-slider[disabled] .ngx-slider-draggable{cursor:not-allowed}::ng-deep .ngx-slider[disabled] .ngx-slider-selection{background:#8b91a2}::ng-deep .ngx-slider[disabled] .ngx-slider-tick{cursor:not-allowed}::ng-deep .ngx-slider[disabled] .ngx-slider-tick.ngx-slider-selected{background:#8b91a2}::ng-deep .ngx-slider .ngx-slider-span{white-space:nowrap;position:absolute;display:inline-block}::ng-deep .ngx-slider .ngx-slider-base{width:100%;height:100%;padding:0}::ng-deep .ngx-slider .ngx-slider-bar-wrapper{left:0;box-sizing:border-box;margin-top:-16px;padding-top:16px;width:100%;height:32px;z-index:1}::ng-deep .ngx-slider .ngx-slider-draggable{cursor:move}::ng-deep .ngx-slider .ngx-slider-bar{left:0;width:100%;height:4px;z-index:1;background:#d8e0f3;border-radius:2px}::ng-deep .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-transparent .ngx-slider-bar{background:0 0}::ng-deep .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-left-out-selection .ngx-slider-bar{background:#df002d}::ng-deep .ngx-slider .ngx-slider-bar-wrapper.ngx-slider-right-out-selection .ngx-slider-bar{background:#03a688}::ng-deep .ngx-slider .ngx-slider-selection{z-index:2;background:#0db9f0;border-radius:2px}::ng-deep .ngx-slider .ngx-slider-pointer{cursor:pointer;width:32px;height:32px;top:-14px;background-color:#0db9f0;z-index:3;border-radius:16px}::ng-deep .ngx-slider .ngx-slider-pointer:after{content:'';width:8px;height:8px;position:absolute;top:12px;left:12px;border-radius:4px;background:#fff}::ng-deep .ngx-slider .ngx-slider-pointer:hover:after{background-color:#fff}::ng-deep .ngx-slider .ngx-slider-pointer.ngx-slider-active{z-index:4}::ng-deep .ngx-slider .ngx-slider-pointer.ngx-slider-active:after{background-color:#451aff}::ng-deep .ngx-slider .ngx-slider-bubble{cursor:default;bottom:16px;padding:1px 3px;color:#55637d;font-size:16px}::ng-deep .ngx-slider .ngx-slider-bubble.ngx-slider-limit{color:#55637d}::ng-deep .ngx-slider .ngx-slider-ticks{box-sizing:border-box;width:100%;height:0;position:absolute;left:0;top:-3px;margin:0;z-index:1;list-style:none}::ng-deep .ngx-slider .ngx-slider-ticks-values-under .ngx-slider-tick-value{top:auto;bottom:-36px}::ng-deep .ngx-slider .ngx-slider-tick{text-align:center;cursor:pointer;width:10px;height:10px;background:#d8e0f3;border-radius:50%;position:absolute;top:0;left:0;margin-left:11px}::ng-deep .ngx-slider .ngx-slider-tick.ngx-slider-selected{background:#0db9f0}::ng-deep .ngx-slider .ngx-slider-tick-value{position:absolute;top:-34px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0)}::ng-deep .ngx-slider .ngx-slider-tick-legend{position:absolute;top:24px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);max-width:50px;white-space:normal}::ng-deep .ngx-slider.vertical{position:relative;width:4px;height:100%;margin:0 20px;padding:0;vertical-align:baseline;touch-action:pan-x}::ng-deep .ngx-slider.vertical .ngx-slider-base{width:100%;height:100%;padding:0}::ng-deep .ngx-slider.vertical .ngx-slider-bar-wrapper{top:auto;left:0;margin:0 0 0 -16px;padding:0 0 0 16px;height:100%;width:32px}::ng-deep .ngx-slider.vertical .ngx-slider-bar{bottom:0;left:auto;width:4px;height:100%}::ng-deep .ngx-slider.vertical .ngx-slider-pointer{left:-14px!important;top:auto;bottom:0}::ng-deep .ngx-slider.vertical .ngx-slider-bubble{left:16px!important;bottom:0}::ng-deep .ngx-slider.vertical .ngx-slider-ticks{height:100%;width:0;left:-3px;top:0;z-index:1}::ng-deep .ngx-slider.vertical .ngx-slider-tick{vertical-align:middle;margin-left:auto;margin-top:11px}::ng-deep .ngx-slider.vertical .ngx-slider-tick-value{left:24px;top:auto;-webkit-transform:translate(0,-28%);transform:translate(0,-28%)}::ng-deep .ngx-slider.vertical .ngx-slider-tick-legend{top:auto;right:24px;-webkit-transform:translate(0,-28%);transform:translate(0,-28%);max-width:none;white-space:nowrap}::ng-deep .ngx-slider.vertical .ngx-slider-ticks-values-under .ngx-slider-tick-value{bottom:auto;left:auto;right:24px}::ng-deep .ngx-slider *{transition:none}::ng-deep .ngx-slider.animate .ngx-slider-bar-wrapper{transition:.3s linear}::ng-deep .ngx-slider.animate .ngx-slider-selection{transition:background-color .3s linear}::ng-deep .ngx-slider.animate .ngx-slider-pointer{transition:.3s linear}::ng-deep .ngx-slider.animate .ngx-slider-bubble{transition:.3s linear}::ng-deep .ngx-slider.animate .ngx-slider-bubble.ngx-slider-limit{transition:opacity .3s linear}::ng-deep .ngx-slider.animate .ngx-slider-bubble.ngx-slider-combined{transition:opacity .3s linear}::ng-deep .ngx-slider.animate .ngx-slider-tick{transition:background-color .3s linear}"],
                host: { class: 'ngx-slider' },
                providers: [NGX_SLIDER_CONTROL_VALUE_ACCESSOR]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }]; }, { value: [{
            type: core.Input
        }], valueChange: [{
            type: core.Output
        }], highValue: [{
            type: core.Input
        }], highValueChange: [{
            type: core.Output
        }], options: [{
            type: core.Input
        }], userChangeStart: [{
            type: core.Output
        }], userChange: [{
            type: core.Output
        }], userChangeEnd: [{
            type: core.Output
        }], sliderElementVerticalClass: [{
            type: core.HostBinding,
            args: ['class.vertical']
        }], sliderElementAnimateClass: [{
            type: core.HostBinding,
            args: ['class.animate']
        }], sliderElementWithLegendClass: [{
            type: core.HostBinding,
            args: ['class.with-legend']
        }], sliderElementDisabledAttr: [{
            type: core.HostBinding,
            args: ['attr.disabled']
        }], manualRefresh: [{
            type: core.Input
        }], triggerFocus: [{
            type: core.Input
        }], onResize: [{
            type: core.HostListener,
            args: ['window:resize', ['$event']]
        }], leftOuterSelectionBarElement: [{
            type: core.ViewChild,
            args: ['leftOuterSelectionBar', { read: SliderElementDirective }]
        }], rightOuterSelectionBarElement: [{
            type: core.ViewChild,
            args: ['rightOuterSelectionBar', { read: SliderElementDirective }]
        }], fullBarElement: [{
            type: core.ViewChild,
            args: ['fullBar', { read: SliderElementDirective }]
        }], selectionBarElement: [{
            type: core.ViewChild,
            args: ['selectionBar', { read: SliderElementDirective }]
        }], minHandleElement: [{
            type: core.ViewChild,
            args: ['minHandle', { read: SliderHandleDirective }]
        }], maxHandleElement: [{
            type: core.ViewChild,
            args: ['maxHandle', { read: SliderHandleDirective }]
        }], floorLabelElement: [{
            type: core.ViewChild,
            args: ['floorLabel', { read: SliderLabelDirective }]
        }], ceilLabelElement: [{
            type: core.ViewChild,
            args: ['ceilLabel', { read: SliderLabelDirective }]
        }], minHandleLabelElement: [{
            type: core.ViewChild,
            args: ['minHandleLabel', { read: SliderLabelDirective }]
        }], maxHandleLabelElement: [{
            type: core.ViewChild,
            args: ['maxHandleLabel', { read: SliderLabelDirective }]
        }], combinedLabelElement: [{
            type: core.ViewChild,
            args: ['combinedLabel', { read: SliderLabelDirective }]
        }], ticksElement: [{
            type: core.ViewChild,
            args: ['ticksElement', { read: SliderElementDirective }]
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return SliderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TooltipWrapperComponent = /** @class */ (function () {
        function TooltipWrapperComponent() {
        }
        TooltipWrapperComponent.propDecorators = {
            template: [{ type: core.Input }],
            tooltip: [{ type: core.Input }],
            placement: [{ type: core.Input }],
            content: [{ type: core.Input }]
        };
TooltipWrapperComponent.ɵfac = function TooltipWrapperComponent_Factory(t) { return new (t || TooltipWrapperComponent)(); };
TooltipWrapperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TooltipWrapperComponent, selectors: [["ngx-slider-tooltip-wrapper"]], inputs: { template: "template", tooltip: "tooltip", placement: "placement", content: "content" }, decls: 2, vars: 2, consts: [[4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "ngx-slider-inner-tooltip"]], template: function TooltipWrapperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TooltipWrapperComponent_ng_container_0_Template, 2, 6, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, TooltipWrapperComponent_ng_container_1_Template, 3, 3, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.template);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], styles: [".ngx-slider-inner-tooltip[_ngcontent-%COMP%]{height:100%}"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipWrapperComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-slider-tooltip-wrapper',
                template: "<ng-container *ngIf=\"template\">\n  <ng-template *ngTemplateOutlet=\"template; context: {tooltip: tooltip, placement: placement, content: content}\"></ng-template>\n</ng-container>\n\n<ng-container *ngIf=\"!template\">\n  <div class=\"ngx-slider-inner-tooltip\" [attr.title]=\"tooltip\" [attr.data-tooltip-placement]=\"placement\">\n    {{content}}\n  </div>\n</ng-container>",
                styles: [".ngx-slider-inner-tooltip{height:100%}"]
            }]
    }], function () { return []; }, { template: [{
            type: core.Input
        }], tooltip: [{
            type: core.Input
        }], placement: [{
            type: core.Input
        }], content: [{
            type: core.Input
        }] }); })();
        return TooltipWrapperComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * NgxSlider module
     *
     * The module exports the slider component
     */
    var NgxSliderModule = /** @class */ (function () {
        function NgxSliderModule() {
        }
NgxSliderModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxSliderModule });
NgxSliderModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxSliderModule_Factory(t) { return new (t || NgxSliderModule)(); }, imports: [[
            common.CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxSliderModule, { declarations: [SliderComponent, SliderElementDirective, SliderHandleDirective, SliderLabelDirective, TooltipWrapperComponent], imports: [ɵngcc1.CommonModule], exports: [SliderComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxSliderModule, [{
        type: core.NgModule,
        args: [{
                imports: [
                    common.CommonModule
                ],
                declarations: [
                    SliderComponent,
                    SliderElementDirective,
                    SliderHandleDirective,
                    SliderLabelDirective,
                    TooltipWrapperComponent
                ],
                exports: [
                    SliderComponent
                ]
            }]
    }], function () { return []; }, null); })();
        return NgxSliderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.NgxSliderModule = NgxSliderModule;
    exports.ChangeContext = ChangeContext;
    exports.PointerType = PointerType;
    exports.LabelType = LabelType;
    exports.Options = Options;
    exports.ɵb = SliderElementDirective;
    exports.ɵc = SliderHandleDirective;
    exports.ɵd = SliderLabelDirective;
    exports.ɵa = SliderComponent;
    exports.ɵe = TooltipWrapperComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=angular-slider-ngx-slider.umd.js.map